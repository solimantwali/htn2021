"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _uiBox = _interopRequireDefault(require("ui-box"));

var _hooks = require("../../hooks");

var _excluded = ["children", "className", "size"],
    _excluded2 = ["className"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var pseudoSelectors = {
  _child: '& > *',
  _firstChild: '& > :first-child:not(:last-child)',
  _middleChild: '& > :not(:first-child):not(:last-child)',
  _lastChild: '& > :last-child:not(:first-child)'
};
var internalStyles = {
  display: 'inline-flex'
};
/**
 * Accessible `Group` component to identify a set of inputs/elements. Implements the WAI-ARIA Group Role
 * @see {@link https://www.w3.org/TR/wai-aria-1.1/#group}
 */

var Group = /*#__PURE__*/(0, _react.memo)( /*#__PURE__*/(0, _react.forwardRef)(function Group(props, ref) {
  var children = props.children,
      className = props.className,
      size = props.size,
      restProps = (0, _objectWithoutProperties2["default"])(props, _excluded);

  var _useStyleConfig = (0, _hooks.useStyleConfig)('Group', {
    size: size
  }, pseudoSelectors, internalStyles),
      themedClassName = _useStyleConfig.className,
      styleProps = (0, _objectWithoutProperties2["default"])(_useStyleConfig, _excluded2);

  var enhancedChildren = _react["default"].Children.map(children, function (child) {
    if (! /*#__PURE__*/_react["default"].isValidElement(child)) {
      return child;
    }

    return /*#__PURE__*/_react["default"].cloneElement(child, {
      // Prefer more granularly defined props if present
      size: child.props.size || size
    });
  });

  return /*#__PURE__*/_react["default"].createElement(_uiBox["default"], (0, _extends2["default"])({
    className: (0, _classnames["default"])(className, themedClassName),
    role: "group",
    ref: ref
  }, styleProps, restProps), enhancedChildren);
}));
Group.propTypes = {
  children: _propTypes["default"].node.isRequired,

  /**
   * Class name passed to the component.
   * Only use if you know what you are doing.
   */
  className: _propTypes["default"].string,

  /**
   * The size passed down to children (for consistency)
   */
  size: _propTypes["default"].oneOf(['small', 'medium', 'large'])
};
var _default = Group;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9ncm91cC9zcmMvR3JvdXAuanMiXSwibmFtZXMiOlsicHNldWRvU2VsZWN0b3JzIiwiX2NoaWxkIiwiX2ZpcnN0Q2hpbGQiLCJfbWlkZGxlQ2hpbGQiLCJfbGFzdENoaWxkIiwiaW50ZXJuYWxTdHlsZXMiLCJkaXNwbGF5IiwiR3JvdXAiLCJwcm9wcyIsInJlZiIsImNoaWxkcmVuIiwiY2xhc3NOYW1lIiwic2l6ZSIsInJlc3RQcm9wcyIsInRoZW1lZENsYXNzTmFtZSIsInN0eWxlUHJvcHMiLCJlbmhhbmNlZENoaWxkcmVuIiwiUmVhY3QiLCJDaGlsZHJlbiIsIm1hcCIsImNoaWxkIiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJub2RlIiwiaXNSZXF1aXJlZCIsInN0cmluZyIsIm9uZU9mIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7O0FBRUEsSUFBTUEsZUFBZSxHQUFHO0FBQ3RCQyxFQUFBQSxNQUFNLEVBQUUsT0FEYztBQUV0QkMsRUFBQUEsV0FBVyxFQUFFLG1DQUZTO0FBR3RCQyxFQUFBQSxZQUFZLEVBQUUseUNBSFE7QUFJdEJDLEVBQUFBLFVBQVUsRUFBRTtBQUpVLENBQXhCO0FBT0EsSUFBTUMsY0FBYyxHQUFHO0FBQ3JCQyxFQUFBQSxPQUFPLEVBQUU7QUFEWSxDQUF2QjtBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLElBQU1DLEtBQUssZ0JBQUcsK0JBQ1osdUJBQVcsU0FBU0EsS0FBVCxDQUFlQyxLQUFmLEVBQXNCQyxHQUF0QixFQUEyQjtBQUNwQyxNQUFRQyxRQUFSLEdBQW9ERixLQUFwRCxDQUFRRSxRQUFSO0FBQUEsTUFBa0JDLFNBQWxCLEdBQW9ESCxLQUFwRCxDQUFrQkcsU0FBbEI7QUFBQSxNQUE2QkMsSUFBN0IsR0FBb0RKLEtBQXBELENBQTZCSSxJQUE3QjtBQUFBLE1BQXNDQyxTQUF0Qyw2Q0FBb0RMLEtBQXBEOztBQUVBLHdCQUFzRCwyQkFDcEQsT0FEb0QsRUFFcEQ7QUFBRUksSUFBQUEsSUFBSSxFQUFKQTtBQUFGLEdBRm9ELEVBR3BEWixlQUhvRCxFQUlwREssY0FKb0QsQ0FBdEQ7QUFBQSxNQUFtQlMsZUFBbkIsbUJBQVFILFNBQVI7QUFBQSxNQUF1Q0ksVUFBdkM7O0FBT0EsTUFBTUMsZ0JBQWdCLEdBQUdDLGtCQUFNQyxRQUFOLENBQWVDLEdBQWYsQ0FBbUJULFFBQW5CLEVBQTZCLFVBQUFVLEtBQUssRUFBSTtBQUM3RCxRQUFJLGVBQUNILGtCQUFNSSxjQUFOLENBQXFCRCxLQUFyQixDQUFMLEVBQWtDO0FBQ2hDLGFBQU9BLEtBQVA7QUFDRDs7QUFFRCx3QkFBT0gsa0JBQU1LLFlBQU4sQ0FBbUJGLEtBQW5CLEVBQTBCO0FBQy9CO0FBQ0FSLE1BQUFBLElBQUksRUFBRVEsS0FBSyxDQUFDWixLQUFOLENBQVlJLElBQVosSUFBb0JBO0FBRkssS0FBMUIsQ0FBUDtBQUlELEdBVHdCLENBQXpCOztBQVdBLHNCQUNFLGdDQUFDLGlCQUFEO0FBQUssSUFBQSxTQUFTLEVBQUUsNEJBQUdELFNBQUgsRUFBY0csZUFBZCxDQUFoQjtBQUFnRCxJQUFBLElBQUksRUFBQyxPQUFyRDtBQUE2RCxJQUFBLEdBQUcsRUFBRUw7QUFBbEUsS0FBMkVNLFVBQTNFLEVBQTJGRixTQUEzRixHQUNHRyxnQkFESCxDQURGO0FBS0QsQ0ExQkQsQ0FEWSxDQUFkO0FBOEJBVCxLQUFLLENBQUNnQixTQUFOLEdBQWtCO0FBQ2hCYixFQUFBQSxRQUFRLEVBQUVjLHNCQUFVQyxJQUFWLENBQWVDLFVBRFQ7O0FBR2hCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0VmLEVBQUFBLFNBQVMsRUFBRWEsc0JBQVVHLE1BUEw7O0FBU2hCO0FBQ0Y7QUFDQTtBQUNFZixFQUFBQSxJQUFJLEVBQUVZLHNCQUFVSSxLQUFWLENBQWdCLENBQUMsT0FBRCxFQUFVLFFBQVYsRUFBb0IsT0FBcEIsQ0FBaEI7QUFaVSxDQUFsQjtlQWVlckIsSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBtZW1vLCBmb3J3YXJkUmVmIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgY3ggZnJvbSAnY2xhc3NuYW1lcydcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBCb3ggZnJvbSAndWktYm94J1xuaW1wb3J0IHsgdXNlU3R5bGVDb25maWcgfSBmcm9tICcuLi8uLi9ob29rcydcblxuY29uc3QgcHNldWRvU2VsZWN0b3JzID0ge1xuICBfY2hpbGQ6ICcmID4gKicsXG4gIF9maXJzdENoaWxkOiAnJiA+IDpmaXJzdC1jaGlsZDpub3QoOmxhc3QtY2hpbGQpJyxcbiAgX21pZGRsZUNoaWxkOiAnJiA+IDpub3QoOmZpcnN0LWNoaWxkKTpub3QoOmxhc3QtY2hpbGQpJyxcbiAgX2xhc3RDaGlsZDogJyYgPiA6bGFzdC1jaGlsZDpub3QoOmZpcnN0LWNoaWxkKSdcbn1cblxuY29uc3QgaW50ZXJuYWxTdHlsZXMgPSB7XG4gIGRpc3BsYXk6ICdpbmxpbmUtZmxleCdcbn1cblxuLyoqXG4gKiBBY2Nlc3NpYmxlIGBHcm91cGAgY29tcG9uZW50IHRvIGlkZW50aWZ5IGEgc2V0IG9mIGlucHV0cy9lbGVtZW50cy4gSW1wbGVtZW50cyB0aGUgV0FJLUFSSUEgR3JvdXAgUm9sZVxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly93d3cudzMub3JnL1RSL3dhaS1hcmlhLTEuMS8jZ3JvdXB9XG4gKi9cbmNvbnN0IEdyb3VwID0gbWVtbyhcbiAgZm9yd2FyZFJlZihmdW5jdGlvbiBHcm91cChwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzaXplLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzXG5cbiAgICBjb25zdCB7IGNsYXNzTmFtZTogdGhlbWVkQ2xhc3NOYW1lLCAuLi5zdHlsZVByb3BzIH0gPSB1c2VTdHlsZUNvbmZpZyhcbiAgICAgICdHcm91cCcsXG4gICAgICB7IHNpemUgfSxcbiAgICAgIHBzZXVkb1NlbGVjdG9ycyxcbiAgICAgIGludGVybmFsU3R5bGVzXG4gICAgKVxuXG4gICAgY29uc3QgZW5oYW5jZWRDaGlsZHJlbiA9IFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgY2hpbGQgPT4ge1xuICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIGNoaWxkXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBSZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGQsIHtcbiAgICAgICAgLy8gUHJlZmVyIG1vcmUgZ3JhbnVsYXJseSBkZWZpbmVkIHByb3BzIGlmIHByZXNlbnRcbiAgICAgICAgc2l6ZTogY2hpbGQucHJvcHMuc2l6ZSB8fCBzaXplXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPEJveCBjbGFzc05hbWU9e2N4KGNsYXNzTmFtZSwgdGhlbWVkQ2xhc3NOYW1lKX0gcm9sZT1cImdyb3VwXCIgcmVmPXtyZWZ9IHsuLi5zdHlsZVByb3BzfSB7Li4ucmVzdFByb3BzfT5cbiAgICAgICAge2VuaGFuY2VkQ2hpbGRyZW59XG4gICAgICA8L0JveD5cbiAgICApXG4gIH0pXG4pXG5cbkdyb3VwLnByb3BUeXBlcyA9IHtcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIENsYXNzIG5hbWUgcGFzc2VkIHRvIHRoZSBjb21wb25lbnQuXG4gICAqIE9ubHkgdXNlIGlmIHlvdSBrbm93IHdoYXQgeW91IGFyZSBkb2luZy5cbiAgICovXG4gIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIHNpemUgcGFzc2VkIGRvd24gdG8gY2hpbGRyZW4gKGZvciBjb25zaXN0ZW5jeSlcbiAgICovXG4gIHNpemU6IFByb3BUeXBlcy5vbmVPZihbJ3NtYWxsJywgJ21lZGl1bScsICdsYXJnZSddKVxufVxuXG5leHBvcnQgZGVmYXVsdCBHcm91cFxuIl19
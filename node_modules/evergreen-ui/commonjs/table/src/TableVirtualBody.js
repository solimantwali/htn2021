"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _reactTinyVirtualList = _interopRequireDefault(require("@segment/react-tiny-virtual-list"));

var _lodash = _interopRequireDefault(require("lodash.debounce"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _hooks = require("../../hooks");

var _layers = require("../../layers");

var _excluded = ["allowAutoHeight", "children", "defaultHeight", "estimatedItemSize", "height", "onScroll", "overscanCount", "scrollOffset", "scrollToAlignment", "scrollToIndex", "useAverageAutoHeightEstimation"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var TableVirtualBody = /*#__PURE__*/(0, _react.memo)(function TableVirtualBody(props) {
  var _props$allowAutoHeigh = props.allowAutoHeight,
      allowAutoHeight = _props$allowAutoHeigh === void 0 ? false : _props$allowAutoHeigh,
      inputChildren = props.children,
      _props$defaultHeight = props.defaultHeight,
      defaultHeight = _props$defaultHeight === void 0 ? 48 : _props$defaultHeight,
      estimatedItemSize = props.estimatedItemSize,
      paneHeight = props.height,
      onScroll = props.onScroll,
      _props$overscanCount = props.overscanCount,
      overscanCount = _props$overscanCount === void 0 ? 5 : _props$overscanCount,
      scrollOffset = props.scrollOffset,
      scrollToAlignment = props.scrollToAlignment,
      scrollToIndex = props.scrollToIndex,
      _props$useAverageAuto = props.useAverageAutoHeightEstimation,
      useAverageAutoHeightEstimation = _props$useAverageAuto === void 0 ? true : _props$useAverageAuto,
      rest = (0, _objectWithoutProperties2["default"])(props, _excluded);
  var forceUpdate = (0, _hooks.useForceUpdate)();
  var autoHeights = [];
  var autoHeightRefs = [];
  var averageAutoHeight = defaultHeight;

  var _useState = (0, _react.useState)(),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      paneRef = _useState2[0],
      setPaneRef = _useState2[1];

  var _useState3 = (0, _react.useState)(false),
      _useState4 = (0, _slicedToArray2["default"])(_useState3, 2),
      isIntegerHeight = _useState4[0],
      setIsIntegerHeight = _useState4[1];

  var _useState5 = (0, _react.useState)(0),
      _useState6 = (0, _slicedToArray2["default"])(_useState5, 2),
      calculatedHeight = _useState6[0],
      setCalculatedHeight = _useState6[1];

  var updateOnResize = function updateOnResize() {
    autoHeights = [];
    autoHeightRefs = [];
    averageAutoHeight = defaultHeight; // Simply return when we now the height of the pane is fixed.

    if (isIntegerHeight) return; // Return if we are in a weird edge case in which the ref is no longer valid.

    if (paneRef && paneRef instanceof Node) {
      var tempCalculatedHeight = paneRef.offsetHeight;

      if (tempCalculatedHeight > 0) {
        // Save the calculated height which is needed for the VirtualList.
        setCalculatedHeight(tempCalculatedHeight); // Prevent updateOnResize being called recursively when there is a valid height.

        return;
      }
    } // When height is still 0 (or paneRef is not valid) try recursively until success.


    requestAnimationFrame(function () {
      updateOnResize();
    });
  };

  var onResize = (0, _lodash["default"])(updateOnResize, 200);
  (0, _react.useEffect)(function () {
    if (props.height !== calculatedHeight) {
      setIsIntegerHeight(Number.isInteger(props.height));
    }
  }, [props.height]);
  (0, _react.useEffect)(function () {
    if (paneRef && paneRef instanceof Node) {
      updateOnResize();
    }
  }, [paneRef]); // Mirrors functionality of componentDidMount and componentWillUnmount.
  // By passing an empty array, will only run on first render, the function returned
  // will be called on component unmount

  (0, _react.useEffect)(function () {
    updateOnResize();
    window.addEventListener('resize', onResize, false);
    return function () {
      window.removeEventListener('resize', onResize);
    };
  }, []);
  /**
   * This function will process all items that have height="auto" set.
   * It will loop through all refs and get calculate the height.
   */

  var processAutoHeights = function processAutoHeights() {
    var isUpdated = false; // This will determine the averageAutoHeight.

    var total = 0;
    var totalAmount = 0; // Loop through all of the refs that have height="auto".

    autoHeightRefs.forEach(function (ref, index) {
      // If the height is already calculated, skip it,
      // but calculate the height for the total.
      if (autoHeights[index]) {
        total += autoHeights[index];
        totalAmount += 1;
        return;
      } // Make sure the ref has a child


      if (ref && ref.childNodes && ref.childNodes[0] && Number.isInteger(ref.childNodes[0].offsetHeight)) {
        var height = ref.childNodes[0].offsetHeight; // Add to the total to calculate the averageAutoHeight.

        total += height;
        totalAmount += 1; // Cache the height.

        autoHeights[index] = height; // Set the update flag to true.

        isUpdated = true;
      }
    }); // Save the average height.

    averageAutoHeight = total / totalAmount; // There are some new heights detected that had previously not been calculated.
    // Call forceUpdate to make sure the virtual list renders again.

    if (isUpdated) forceUpdate();
  };

  var onVirtualHelperRef = function onVirtualHelperRef(index, ref) {
    autoHeightRefs[index] = ref;
    requestAnimationFrame(function () {
      processAutoHeights();
    });
  };

  var getItemSize = function getItemSize(children) {
    // Prefer to return a array of all heights.
    if (!allowAutoHeight) {
      return children.map(function (child) {
        if (! /*#__PURE__*/_react["default"].isValidElement(child)) return defaultHeight;
        var height = child.props.height;

        if (Number.isInteger(height)) {
          return height;
        }

        return defaultHeight;
      });
    } // If allowAutoHeight is true, return a function instead.


    var itemSizeFn = function itemSizeFn(index) {
      if (! /*#__PURE__*/_react["default"].isValidElement(children[index])) return defaultHeight;
      var height = children[index].props.height; // When the height is number simply, simply return it.

      if (Number.isInteger(height)) {
        return height;
      } // When allowAutoHeight is set and  the height is set to "auto"...


      if (allowAutoHeight && children[index].props.height === 'auto') {
        // ... and the height is calculated, return the calculated height.
        if (autoHeights[index]) return autoHeights[index]; // ... if the height is not yet calculated, return the averge

        if (useAverageAutoHeightEstimation) return averageAutoHeight;
      } // Return the default height.


      return defaultHeight;
    };

    return itemSizeFn;
  }; // Children always needs to be an array.


  var children = Array.isArray(inputChildren) ? inputChildren : _react["default"].Children.toArray(inputChildren);
  var itemSize = getItemSize(children);
  return /*#__PURE__*/_react["default"].createElement(_layers.Pane, (0, _extends2["default"])({
    "data-evergreen-table-body": true,
    ref: setPaneRef,
    height: paneHeight,
    flex: "1",
    overflow: "hidden"
  }, rest), /*#__PURE__*/_react["default"].createElement(_reactTinyVirtualList["default"], {
    height: isIntegerHeight ? paneHeight : calculatedHeight,
    width: "100%",
    estimatedItemSize: allowAutoHeight && useAverageAutoHeightEstimation ? averageAutoHeight : estimatedItemSize || null,
    itemSize: itemSize,
    overscanCount: overscanCount,
    itemCount: _react["default"].Children.count(children),
    scrollToIndex: scrollToIndex,
    scrollOffset: scrollOffset,
    scrollToAlignment: scrollToAlignment,
    onScroll: onScroll,
    renderItem: function renderItem(_ref) {
      var index = _ref.index,
          style = _ref.style;
      var child = children[index];
      var key = child.key || index;
      var props = {
        key: key,
        style: style
      }; // If some children are strings by accident, support this gracefully.

      if (! /*#__PURE__*/_react["default"].isValidElement(child)) {
        if (typeof child === 'string') {
          return /*#__PURE__*/_react["default"].createElement("div", props, child);
        }

        return /*#__PURE__*/_react["default"].createElement("div", props, "\xA0");
      } // When allowing height="auto" for rows, and a auto height item is
      // rendered for the first time...


      if (allowAutoHeight && /*#__PURE__*/_react["default"].isValidElement(child) && child.props.height === 'auto' && // ... and only when the height is not already been calculated.
      !autoHeights[index]) {
        // ... render the item in a helper div, the ref is used to calculate
        // the height of its children.
        return /*#__PURE__*/_react["default"].createElement("div", (0, _extends2["default"])({
          ref: function ref(_ref2) {
            return onVirtualHelperRef(index, _ref2);
          },
          "data-virtual-index": index
        }, props, {
          style: _objectSpread({
            opacity: 0
          }, props.style)
        }), child);
      } // When allowAutoHeight is false, or when the height is known.
      // Simply render the item.


      return /*#__PURE__*/_react["default"].cloneElement(child, props);
    }
  }));
});
TableVirtualBody.propTypes = _objectSpread(_objectSpread({}, _layers.Pane.propTypes), {}, {
  /**
   * Children needs to be an array of a single node.
   */
  children: _propTypes["default"].oneOfType([_propTypes["default"].arrayOf(_propTypes["default"].node), _propTypes["default"].node]),

  /**
   * Default height of each row.
   * 48 is the default height of a TableRow.
   */
  defaultHeight: _propTypes["default"].number,

  /**
   * When true, support `height="auto"` on children being rendered.
   * This is somewhat of an expirmental feature.
   */
  allowAutoHeight: _propTypes["default"].bool,

  /**
   * The overscanCount property passed to react-tiny-virtual-list.
   */
  overscanCount: _propTypes["default"].number,

  /**
   * When passed, this is used as the `estimatedItemSize` in react-tiny-virtual-list.
   * Only when `allowAutoHeight` and`useAverageAutoHeightEstimation` are false.
   */
  estimatedItemSize: _propTypes["default"].number,

  /**
   * When allowAutoHeight is true and this prop is true, the estimated height
   * will be computed based on the average height of auto height rows.
   */
  useAverageAutoHeightEstimation: _propTypes["default"].bool,

  /**
   * The scrollToIndex property passed to react-tiny-virtual-list
   */
  scrollToIndex: _propTypes["default"].number,

  /**
   * The scrollOffset property passed to react-tiny-virtual-list
   */
  scrollOffset: _propTypes["default"].number,

  /**
   * The scrollToAlignment property passed to react-tiny-virtual-list
   */
  scrollToAlignment: _propTypes["default"].oneOf(['start', 'center', 'end', 'auto']),

  /**
   * The onScroll callback passed to react-tiny-virtual-list
   */
  onScroll: _propTypes["default"].func
});
var _default = TableVirtualBody;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvVGFibGVWaXJ0dWFsQm9keS5qcyJdLCJuYW1lcyI6WyJUYWJsZVZpcnR1YWxCb2R5IiwicHJvcHMiLCJhbGxvd0F1dG9IZWlnaHQiLCJpbnB1dENoaWxkcmVuIiwiY2hpbGRyZW4iLCJkZWZhdWx0SGVpZ2h0IiwiZXN0aW1hdGVkSXRlbVNpemUiLCJwYW5lSGVpZ2h0IiwiaGVpZ2h0Iiwib25TY3JvbGwiLCJvdmVyc2NhbkNvdW50Iiwic2Nyb2xsT2Zmc2V0Iiwic2Nyb2xsVG9BbGlnbm1lbnQiLCJzY3JvbGxUb0luZGV4IiwidXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uIiwicmVzdCIsImZvcmNlVXBkYXRlIiwiYXV0b0hlaWdodHMiLCJhdXRvSGVpZ2h0UmVmcyIsImF2ZXJhZ2VBdXRvSGVpZ2h0IiwicGFuZVJlZiIsInNldFBhbmVSZWYiLCJpc0ludGVnZXJIZWlnaHQiLCJzZXRJc0ludGVnZXJIZWlnaHQiLCJjYWxjdWxhdGVkSGVpZ2h0Iiwic2V0Q2FsY3VsYXRlZEhlaWdodCIsInVwZGF0ZU9uUmVzaXplIiwiTm9kZSIsInRlbXBDYWxjdWxhdGVkSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib25SZXNpemUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInByb2Nlc3NBdXRvSGVpZ2h0cyIsImlzVXBkYXRlZCIsInRvdGFsIiwidG90YWxBbW91bnQiLCJmb3JFYWNoIiwicmVmIiwiaW5kZXgiLCJjaGlsZE5vZGVzIiwib25WaXJ0dWFsSGVscGVyUmVmIiwiZ2V0SXRlbVNpemUiLCJtYXAiLCJjaGlsZCIsIlJlYWN0IiwiaXNWYWxpZEVsZW1lbnQiLCJpdGVtU2l6ZUZuIiwiQXJyYXkiLCJpc0FycmF5IiwiQ2hpbGRyZW4iLCJ0b0FycmF5IiwiaXRlbVNpemUiLCJjb3VudCIsInN0eWxlIiwia2V5Iiwib3BhY2l0eSIsImNsb25lRWxlbWVudCIsInByb3BUeXBlcyIsIlBhbmUiLCJQcm9wVHlwZXMiLCJvbmVPZlR5cGUiLCJhcnJheU9mIiwibm9kZSIsIm51bWJlciIsImJvb2wiLCJvbmVPZiIsImZ1bmMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsZ0JBQWdCLGdCQUFHLGlCQUFLLFNBQVNBLGdCQUFULENBQTBCQyxLQUExQixFQUFpQztBQUM3RCw4QkFhSUEsS0FiSixDQUNFQyxlQURGO0FBQUEsTUFDRUEsZUFERixzQ0FDb0IsS0FEcEI7QUFBQSxNQUVZQyxhQUZaLEdBYUlGLEtBYkosQ0FFRUcsUUFGRjtBQUFBLDZCQWFJSCxLQWJKLENBR0VJLGFBSEY7QUFBQSxNQUdFQSxhQUhGLHFDQUdrQixFQUhsQjtBQUFBLE1BSUVDLGlCQUpGLEdBYUlMLEtBYkosQ0FJRUssaUJBSkY7QUFBQSxNQUtVQyxVQUxWLEdBYUlOLEtBYkosQ0FLRU8sTUFMRjtBQUFBLE1BTUVDLFFBTkYsR0FhSVIsS0FiSixDQU1FUSxRQU5GO0FBQUEsNkJBYUlSLEtBYkosQ0FPRVMsYUFQRjtBQUFBLE1BT0VBLGFBUEYscUNBT2tCLENBUGxCO0FBQUEsTUFRRUMsWUFSRixHQWFJVixLQWJKLENBUUVVLFlBUkY7QUFBQSxNQVNFQyxpQkFURixHQWFJWCxLQWJKLENBU0VXLGlCQVRGO0FBQUEsTUFVRUMsYUFWRixHQWFJWixLQWJKLENBVUVZLGFBVkY7QUFBQSw4QkFhSVosS0FiSixDQVdFYSw4QkFYRjtBQUFBLE1BV0VBLDhCQVhGLHNDQVdtQyxJQVhuQztBQUFBLE1BWUtDLElBWkwsNkNBYUlkLEtBYko7QUFlQSxNQUFNZSxXQUFXLEdBQUcsNEJBQXBCO0FBQ0EsTUFBSUMsV0FBVyxHQUFHLEVBQWxCO0FBQ0EsTUFBSUMsY0FBYyxHQUFHLEVBQXJCO0FBQ0EsTUFBSUMsaUJBQWlCLEdB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QUE0QkU7QUFDRjtBQUNBO0FBQ0E7QUFDRTlELEVBQUFBLGlCQUFpQixFQUFFMEQsc0JBQVVJLE1BaEMvQjs7QUFrQ0U7QUFDRjtBQUNBO0FBQ0E7QUFDRXRELEVBQUFBLDhCQUE4QixFQUFFa0Qsc0JBQVVLLElBdEM1Qzs7QUF3Q0U7QUFDRjtBQUNBO0FBQ0V4RCxFQUFBQSxhQUFhLEVBQUVtRCxzQkFBVUksTUEzQzNCOztBQTRDRTtBQUNGO0FBQ0E7QUFDRXpELEVBQUFBLFlBQVksRUFBRXFELHNCQUFVSSxNQS9DMUI7O0FBZ0RFO0FBQ0Y7QUFDQTtBQUNFeEQsRUFBQUEsaUJBQWlCLEVBQUVvRCxzQkFBVU0sS0FBVixDQUFnQixDQUFDLE9BQUQsRUFBVSxRQUFWLEVBQW9CLEtBQXBCLEVBQTJCLE1BQTNCLENBQWhCLENBbkRyQjs7QUFvREU7QUFDRjtBQUNBO0FBQ0U3RCxFQUFBQSxRQUFRLEVBQUV1RCxzQkFBVU87QUF2RHRCO2VBMERldkUsZ0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgbWVtbywgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFZpcnR1YWxMaXN0IGZyb20gJ0BzZWdtZW50L3JlYWN0LXRpbnktdmlydHVhbC1saXN0J1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC5kZWJvdW5jZSdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCB7IHVzZUZvcmNlVXBkYXRlIH0gZnJvbSAnLi4vLi4vaG9va3MnXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vLi4vbGF5ZXJzJ1xuXG5jb25zdCBUYWJsZVZpcnR1YWxCb2R5ID0gbWVtbyhmdW5jdGlvbiBUYWJsZVZpcnR1YWxCb2R5KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBhbGxvd0F1dG9IZWlnaHQgPSBmYWxzZSxcbiAgICBjaGlsZHJlbjogaW5wdXRDaGlsZHJlbixcbiAgICBkZWZhdWx0SGVpZ2h0ID0gNDgsXG4gICAgZXN0aW1hdGVkSXRlbVNpemUsXG4gICAgaGVpZ2h0OiBwYW5lSGVpZ2h0LFxuICAgIG9uU2Nyb2xsLFxuICAgIG92ZXJzY2FuQ291bnQgPSA1LFxuICAgIHNjcm9sbE9mZnNldCxcbiAgICBzY3JvbGxUb0FsaWdubWVudCxcbiAgICBzY3JvbGxUb0luZGV4LFxuICAgIHVzZUF2ZXJhZ2VBdXRvSGVpZ2h0RXN0aW1hdGlvbiA9IHRydWUsXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKClcbiAgbGV0IGF1dG9IZWlnaHRzID0gW11cbiAgbGV0IGF1dG9IZWlnaHRSZWZzID0gW11cbiAgbGV0IGF2ZXJhZ2VBdXRvSGVpZ2h0ID0gZGVmYXVsdEhlaWdodFxuXG4gIGNvbnN0IFtwYW5lUmVmLCBzZXRQYW5lUmVmXSA9IHVzZVN0YXRlKClcbiAgY29uc3QgW2lzSW50ZWdlckhlaWdodCwgc2V0SXNJbnRlZ2VySGVpZ2h0XSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbY2FsY3VsYXRlZEhlaWdodCwgc2V0Q2FsY3VsYXRlZEhlaWdodF0gPSB1c2VTdGF0ZSgwKVxuXG4gIGNvbnN0IHVwZGF0ZU9uUmVzaXplID0gKCkgPT4ge1xuICAgIGF1dG9IZWlnaHRzID0gW11cbiAgICBhdXRvSGVpZ2h0UmVmcyA9IFtdXG4gICAgYXZlcmFnZUF1dG9IZWlnaHQgPSBkZWZhdWx0SGVpZ2h0XG5cbiAgICAvLyBTaW1wbHkgcmV0dXJuIHdoZW4gd2Ugbm93IHRoZSBoZWlnaHQgb2YgdGhlIHBhbmUgaXMgZml4ZWQuXG4gICAgaWYgKGlzSW50ZWdlckhlaWdodCkgcmV0dXJuXG5cbiAgICAvLyBSZXR1cm4gaWYgd2UgYXJlIGluIGEgd2VpcmQgZWRnZSBjYXNlIGluIHdoaWNoIHRoZSByZWYgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIGlmIChwYW5lUmVmICYmIHBhbmVSZWYgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICBjb25zdCB0ZW1wQ2FsY3VsYXRlZEhlaWdodCA9IHBhbmVSZWYub2Zmc2V0SGVpZ2h0XG5cbiAgICAgIGlmICh0ZW1wQ2FsY3VsYXRlZEhlaWdodCA+IDApIHtcbiAgICAgICAgLy8gU2F2ZSB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgd2hpY2ggaXMgbmVlZGVkIGZvciB0aGUgVmlydHVhbExpc3QuXG4gICAgICAgIHNldENhbGN1bGF0ZWRIZWlnaHQodGVtcENhbGN1bGF0ZWRIZWlnaHQpXG5cbiAgICAgICAgLy8gUHJldmVudCB1cGRhdGVPblJlc2l6ZSBiZWluZyBjYWxsZWQgcmVjdXJzaXZlbHkgd2hlbiB0aGVyZSBpcyBhIHZhbGlkIGhlaWdodC5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBoZWlnaHQgaXMgc3RpbGwgMCAob3IgcGFuZVJlZiBpcyBub3QgdmFsaWQpIHRyeSByZWN1cnNpdmVseSB1bnRpbCBzdWNjZXNzLlxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB1cGRhdGVPblJlc2l6ZSgpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IG9uUmVzaXplID0gZGVib3VuY2UodXBkYXRlT25SZXNpemUsIDIwMClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9wcy5oZWlnaHQgIT09IGNhbGN1bGF0ZWRIZWlnaHQpIHtcbiAgICAgIHNldElzSW50ZWdlckhlaWdodChOdW1iZXIuaXNJbnRlZ2VyKHByb3BzLmhlaWdodCkpXG4gICAgfVxuICB9LCBbcHJvcHMuaGVpZ2h0XSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwYW5lUmVmICYmIHBhbmVSZWYgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICB1cGRhdGVPblJlc2l6ZSgpXG4gICAgfVxuICB9LCBbcGFuZVJlZl0pXG5cbiAgLy8gTWlycm9ycyBmdW5jdGlvbmFsaXR5IG9mIGNvbXBvbmVudERpZE1vdW50IGFuZCBjb21wb25lbnRXaWxsVW5tb3VudC5cbiAgLy8gQnkgcGFzc2luZyBhbiBlbXB0eSBhcnJheSwgd2lsbCBvbmx5IHJ1biBvbiBmaXJzdCByZW5kZXIsIHRoZSBmdW5jdGlvbiByZXR1cm5lZFxuICAvLyB3aWxsIGJlIGNhbGxlZCBvbiBjb21wb25lbnQgdW5tb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHVwZGF0ZU9uUmVzaXplKClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUsIGZhbHNlKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSlcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcHJvY2VzcyBhbGwgaXRlbXMgdGhhdCBoYXZlIGhlaWdodD1cImF1dG9cIiBzZXQuXG4gICAqIEl0IHdpbGwgbG9vcCB0aHJvdWdoIGFsbCByZWZzIGFuZCBnZXQgY2FsY3VsYXRlIHRoZSBoZWlnaHQuXG4gICAqL1xuICBjb25zdCBwcm9jZXNzQXV0b0hlaWdodHMgPSAoKSA9PiB7XG4gICAgbGV0IGlzVXBkYXRlZCA9IGZhbHNlXG5cbiAgICAvLyBUaGlzIHdpbGwgZGV0ZXJtaW5lIHRoZSBhdmVyYWdlQXV0b0hlaWdodC5cbiAgICBsZXQgdG90YWwgPSAwXG4gICAgbGV0IHRvdGFsQW1vdW50ID0gMFxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBvZiB0aGUgcmVmcyB0aGF0IGhhdmUgaGVpZ2h0PVwiYXV0b1wiLlxuICAgIGF1dG9IZWlnaHRSZWZzLmZvckVhY2goKHJlZiwgaW5kZXgpID0+IHtcbiAgICAgIC8vIElmIHRoZSBoZWlnaHQgaXMgYWxyZWFkeSBjYWxjdWxhdGVkLCBza2lwIGl0LFxuICAgICAgLy8gYnV0IGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGZvciB0aGUgdG90YWwuXG4gICAgICBpZiAoYXV0b0hlaWdodHNbaW5kZXhdKSB7XG4gICAgICAgIHRvdGFsICs9IGF1dG9IZWlnaHRzW2luZGV4XVxuICAgICAgICB0b3RhbEFtb3VudCArPSAxXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHJlZiBoYXMgYSBjaGlsZFxuICAgICAgaWYgKHJlZiAmJiByZWYuY2hpbGROb2RlcyAmJiByZWYuY2hpbGROb2Rlc1swXSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHJlZi5jaGlsZE5vZGVzWzBdLm9mZnNldEhlaWdodCkpIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcmVmLmNoaWxkTm9kZXNbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAgICAgLy8gQWRkIHRvIHRoZSB0b3RhbCB0byBjYWxjdWxhdGUgdGhlIGF2ZXJhZ2VBdXRvSGVpZ2h0LlxuICAgICAgICB0b3RhbCArPSBoZWlnaHRcbiAgICAgICAgdG90YWxBbW91bnQgKz0gMVxuXG4gICAgICAgIC8vIENhY2hlIHRoZSBoZWlnaHQuXG4gICAgICAgIGF1dG9IZWlnaHRzW2luZGV4XSA9IGhlaWdodFxuXG4gICAgICAgIC8vIFNldCB0aGUgdXBkYXRlIGZsYWcgdG8gdHJ1ZS5cbiAgICAgICAgaXNVcGRhdGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBTYXZlIHRoZSBhdmVyYWdlIGhlaWdodC5cbiAgICBhdmVyYWdlQXV0b0hlaWdodCA9IHRvdGFsIC8gdG90YWxBbW91bnRcblxuICAgIC8vIFRoZXJlIGFyZSBzb21lIG5ldyBoZWlnaHRzIGRldGVjdGVkIHRoYXQgaGFkIHByZXZpb3VzbHkgbm90IGJlZW4gY2FsY3VsYXRlZC5cbiAgICAvLyBDYWxsIGZvcmNlVXBkYXRlIHRvIG1ha2Ugc3VyZSB0aGUgdmlydHVhbCBsaXN0IHJlbmRlcnMgYWdhaW4uXG4gICAgaWYgKGlzVXBkYXRlZCkgZm9yY2VVcGRhdGUoKVxuICB9XG5cbiAgY29uc3Qgb25WaXJ0dWFsSGVscGVyUmVmID0gKGluZGV4LCByZWYpID0+IHtcbiAgICBhdXRvSGVpZ2h0UmVmc1tpbmRleF0gPSByZWZcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBwcm9jZXNzQXV0b0hlaWdodHMoKVxuICAgIH0pXG4gIH1cblxuICBjb25zdCBnZXRJdGVtU2l6ZSA9IGNoaWxkcmVuID0+IHtcbiAgICAvLyBQcmVmZXIgdG8gcmV0dXJuIGEgYXJyYXkgb2YgYWxsIGhlaWdodHMuXG4gICAgaWYgKCFhbGxvd0F1dG9IZWlnaHQpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkgcmV0dXJuIGRlZmF1bHRIZWlnaHRcbiAgICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IGNoaWxkLnByb3BzXG5cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaGVpZ2h0KSkge1xuICAgICAgICAgIHJldHVybiBoZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0SGVpZ2h0XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIElmIGFsbG93QXV0b0hlaWdodCBpcyB0cnVlLCByZXR1cm4gYSBmdW5jdGlvbiBpbnN0ZWFkLlxuICAgIGNvbnN0IGl0ZW1TaXplRm4gPSBpbmRleCA9PiB7XG4gICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuW2luZGV4XSkpIHJldHVybiBkZWZhdWx0SGVpZ2h0XG4gICAgICBjb25zdCB7IGhlaWdodCB9ID0gY2hpbGRyZW5baW5kZXhdLnByb3BzXG5cbiAgICAgIC8vIFdoZW4gdGhlIGhlaWdodCBpcyBudW1iZXIgc2ltcGx5LCBzaW1wbHkgcmV0dXJuIGl0LlxuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaGVpZ2h0KSkge1xuICAgICAgICByZXR1cm4gaGVpZ2h0XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gYWxsb3dBdXRvSGVpZ2h0IGlzIHNldCBhbmQgIHRoZSBoZWlnaHQgaXMgc2V0IHRvIFwiYXV0b1wiLi4uXG4gICAgICBpZiAoYWxsb3dBdXRvSGVpZ2h0ICYmIGNoaWxkcmVuW2luZGV4XS5wcm9wcy5oZWlnaHQgPT09ICdhdXRvJykge1xuICAgICAgICAvLyAuLi4gYW5kIHRoZSBoZWlnaHQgaXMgY2FsY3VsYXRlZCwgcmV0dXJuIHRoZSBjYWxjdWxhdGVkIGhlaWdodC5cbiAgICAgICAgaWYgKGF1dG9IZWlnaHRzW2luZGV4XSkgcmV0dXJuIGF1dG9IZWlnaHRzW2luZGV4XVxuXG4gICAgICAgIC8vIC4uLiBpZiB0aGUgaGVpZ2h0IGlzIG5vdCB5ZXQgY2FsY3VsYXRlZCwgcmV0dXJuIHRoZSBhdmVyZ2VcbiAgICAgICAgaWYgKHVzZUF2ZXJhZ2VBdXRvSGVpZ2h0RXN0aW1hdGlvbikgcmV0dXJuIGF2ZXJhZ2VBdXRvSGVpZ2h0XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgZGVmYXVsdCBoZWlnaHQuXG4gICAgICByZXR1cm4gZGVmYXVsdEhlaWdodFxuICAgIH1cblxuICAgIHJldHVybiBpdGVtU2l6ZUZuXG4gIH1cblxuICAvLyBDaGlsZHJlbiBhbHdheXMgbmVlZHMgdG8gYmUgYW4gYXJyYXkuXG4gIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuaXNBcnJheShpbnB1dENoaWxkcmVuKSA/IGlucHV0Q2hpbGRyZW4gOiBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGlucHV0Q2hpbGRyZW4pXG5cbiAgY29uc3QgaXRlbVNpemUgPSBnZXRJdGVtU2l6ZShjaGlsZHJlbilcblxuICByZXR1cm4gKFxuICAgIDxQYW5lIGRhdGEtZXZlcmdyZWVuLXRhYmxlLWJvZHkgcmVmPXtzZXRQYW5lUmVmfSBoZWlnaHQ9e3BhbmVIZWlnaHR9IGZsZXg9XCIxXCIgb3ZlcmZsb3c9XCJoaWRkZW5cIiB7Li4ucmVzdH0+XG4gICAgICA8VmlydHVhbExpc3RcbiAgICAgICAgaGVpZ2h0PXtpc0ludGVnZXJIZWlnaHQgPyBwYW5lSGVpZ2h0IDogY2FsY3VsYXRlZEhlaWdodH1cbiAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgZXN0aW1hdGVkSXRlbVNpemU9e1xuICAgICAgICAgIGFsbG93QXV0b0hlaWdodCAmJiB1c2VBdmVyYWdlQXV0b0hlaWdodEVzdGltYXRpb24gPyBhdmVyYWdlQXV0b0hlaWdodCA6IGVzdGltYXRlZEl0ZW1TaXplIHx8IG51bGxcbiAgICAgICAgfVxuICAgICAgICBpdGVtU2l6ZT17aXRlbVNpemV9XG4gICAgICAgIG92ZXJzY2FuQ291bnQ9e292ZXJzY2FuQ291bnR9XG4gICAgICAgIGl0ZW1Db3VudD17UmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pfVxuICAgICAgICBzY3JvbGxUb0luZGV4PXtzY3JvbGxUb0luZGV4fVxuICAgICAgICBzY3JvbGxPZmZzZXQ9e3Njcm9sbE9mZnNldH1cbiAgICAgICAgc2Nyb2xsVG9BbGlnbm1lbnQ9e3Njcm9sbFRvQWxpZ25tZW50fVxuICAgICAgICBvblNjcm9sbD17b25TY3JvbGx9XG4gICAgICAgIHJlbmRlckl0ZW09eyh7IGluZGV4LCBzdHlsZSB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpbmRleF1cbiAgICAgICAgICBjb25zdCBrZXkgPSBjaGlsZC5rZXkgfHwgaW5kZXhcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgc29tZSBjaGlsZHJlbiBhcmUgc3RyaW5ncyBieSBhY2NpZGVudCwgc3VwcG9ydCB0aGlzIGdyYWNlZnVsbHkuXG4gICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiA8ZGl2IHsuLi5wcm9wc30+e2NoaWxkfTwvZGl2PlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gPGRpdiB7Li4ucHJvcHN9PiZuYnNwOzwvZGl2PlxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gYWxsb3dpbmcgaGVpZ2h0PVwiYXV0b1wiIGZvciByb3dzLCBhbmQgYSBhdXRvIGhlaWdodCBpdGVtIGlzXG4gICAgICAgICAgLy8gcmVuZGVyZWQgZm9yIHRoZSBmaXJzdCB0aW1lLi4uXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgYWxsb3dBdXRvSGVpZ2h0ICYmXG4gICAgICAgICAgICBSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkgJiZcbiAgICAgICAgICAgIGNoaWxkLnByb3BzLmhlaWdodCA9PT0gJ2F1dG8nICYmXG4gICAgICAgICAgICAvLyAuLi4gYW5kIG9ubHkgd2hlbiB0aGUgaGVpZ2h0IGlzIG5vdCBhbHJlYWR5IGJlZW4gY2FsY3VsYXRlZC5cbiAgICAgICAgICAgICFhdXRvSGVpZ2h0c1tpbmRleF1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIC4uLiByZW5kZXIgdGhlIGl0ZW0gaW4gYSBoZWxwZXIgZGl2LCB0aGUgcmVmIGlzIHVzZWQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICByZWY9e3JlZiA9PiBvblZpcnR1YWxIZWxwZXJSZWYoaW5kZXgsIHJlZil9XG4gICAgICAgICAgICAgICAgZGF0YS12aXJ0dWFsLWluZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAuLi5wcm9wcy5zdHlsZVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7Y2hpbGR9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gYWxsb3dBdXRvSGVpZ2h0IGlzIGZhbHNlLCBvciB3aGVuIHRoZSBoZWlnaHQgaXMga25vd24uXG4gICAgICAgICAgLy8gU2ltcGx5IHJlbmRlciB0aGUgaXRlbS5cbiAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBwcm9wcylcbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgPC9QYW5lPlxuICApXG59KVxuXG5UYWJsZVZpcnR1YWxCb2R5LnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIENvbXBvc2VzIHRoZSBQYW5lIGNvbXBvbmVudCBhcyB0aGUgYmFzZS5cbiAgICovXG4gIC4uLlBhbmUucHJvcFR5cGVzLFxuXG4gIC8qKlxuICAgKiBDaGlsZHJlbiBuZWVkcyB0byBiZSBhbiBhcnJheSBvZiBhIHNpbmdsZSBub2RlLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5ub2RlKSwgUHJvcFR5cGVzLm5vZGVdKSxcblxuICAvKipcbiAgICogRGVmYXVsdCBoZWlnaHQgb2YgZWFjaCByb3cuXG4gICAqIDQ4IGlzIHRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIFRhYmxlUm93LlxuICAgKi9cbiAgZGVmYXVsdEhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogV2hlbiB0cnVlLCBzdXBwb3J0IGBoZWlnaHQ9XCJhdXRvXCJgIG9uIGNoaWxkcmVuIGJlaW5nIHJlbmRlcmVkLlxuICAgKiBUaGlzIGlzIHNvbWV3aGF0IG9mIGFuIGV4cGlybWVudGFsIGZlYXR1cmUuXG4gICAqL1xuICBhbGxvd0F1dG9IZWlnaHQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgb3ZlcnNjYW5Db3VudCBwcm9wZXJ0eSBwYXNzZWQgdG8gcmVhY3QtdGlueS12aXJ0dWFsLWxpc3QuXG4gICAqL1xuICBvdmVyc2NhbkNvdW50OiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBXaGVuIHBhc3NlZCwgdGhpcyBpcyB1c2VkIGFzIHRoZSBgZXN0aW1hdGVkSXRlbVNpemVgIGluIHJlYWN0LXRpbnktdmlydHVhbC1saXN0LlxuICAgKiBPbmx5IHdoZW4gYGFsbG93QXV0b0hlaWdodGAgYW5kYHVzZUF2ZXJhZ2VBdXRvSGVpZ2h0RXN0aW1hdGlvbmAgYXJlIGZhbHNlLlxuICAgKi9cbiAgZXN0aW1hdGVkSXRlbVNpemU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFdoZW4gYWxsb3dBdXRvSGVpZ2h0IGlzIHRydWUgYW5kIHRoaXMgcHJvcCBpcyB0cnVlLCB0aGUgZXN0aW1hdGVkIGhlaWdodFxuICAgKiB3aWxsIGJlIGNvbXB1dGVkIGJhc2VkIG9uIHRoZSBhdmVyYWdlIGhlaWdodCBvZiBhdXRvIGhlaWdodCByb3dzLlxuICAgKi9cbiAgdXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIHNjcm9sbFRvSW5kZXggcHJvcGVydHkgcGFzc2VkIHRvIHJlYWN0LXRpbnktdmlydHVhbC1saXN0XG4gICAqL1xuICBzY3JvbGxUb0luZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogVGhlIHNjcm9sbE9mZnNldCBwcm9wZXJ0eSBwYXNzZWQgdG8gcmVhY3QtdGlueS12aXJ0dWFsLWxpc3RcbiAgICovXG4gIHNjcm9sbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIFRoZSBzY3JvbGxUb0FsaWdubWVudCBwcm9wZXJ0eSBwYXNzZWQgdG8gcmVhY3QtdGlueS12aXJ0dWFsLWxpc3RcbiAgICovXG4gIHNjcm9sbFRvQWxpZ25tZW50OiBQcm9wVHlwZXMub25lT2YoWydzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2F1dG8nXSksXG4gIC8qKlxuICAgKiBUaGUgb25TY3JvbGwgY2FsbGJhY2sgcGFzc2VkIHRvIHJlYWN0LXRpbnktdmlydHVhbC1saXN0XG4gICAqL1xuICBvblNjcm9sbDogUHJvcFR5cGVzLmZ1bmNcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGFibGVWaXJ0dWFsQm9keVxuIl19
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IconWrapper = void 0;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _objectWithoutProperties2 = _interopRequireDefault(require("@babel/runtime/helpers/objectWithoutProperties"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactIs = _interopRequireDefault(require("react-is"));

var _uiBox = _interopRequireDefault(require("ui-box"));

var _excluded = ["color", "icon", "size", "title"];

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * This is an internal helper component for rendering custom or Evergreen icons
 * Box props are applied to the outer Box container, and Evergreen icon-specific props are added to the icon element.
 */
var IconWrapper = /*#__PURE__*/(0, _react.memo)( /*#__PURE__*/(0, _react.forwardRef)(function Icon(_ref, ref) {
  var color = _ref.color,
      icon = _ref.icon,
      size = _ref.size,
      title = _ref.title,
      props = (0, _objectWithoutProperties2["default"])(_ref, _excluded);

  if (!icon || typeof icon === 'string') {
    return null;
  }

  var iconProps = {
    color: color,
    size: size,
    title: title
  };
  var iconWithProps = null;

  if (_reactIs["default"].isValidElementType(icon)) {
    var Component = icon;
    iconWithProps = /*#__PURE__*/_react["default"].createElement(Component, (0, _extends2["default"])({
      ref: ref
    }, iconProps));
  } else if ( /*#__PURE__*/_react["default"].isValidElement(icon)) {
    iconWithProps = /*#__PURE__*/_react["default"].cloneElement(icon, _objectSpread(_objectSpread(_objectSpread({}, iconProps), icon.props), {}, {
      ref: ref
    }));
  }

  return /*#__PURE__*/_react["default"].createElement(_uiBox["default"], (0, _extends2["default"])({
    display: "inline-flex"
  }, props), iconWithProps);
}));
exports.IconWrapper = IconWrapper;
IconWrapper.propTypes = {
  /**
   * Color of icon. Equivalent to setting CSS `fill` property.
   */
  color: _propTypes["default"].string,

  /**
   * The icon component - whether an Evergreen icon or a custom icon node:
   *
   * - If `null` or `undefined` or `false`, this component will render nothing.
   * - If given a `JSX.Element`, that element will be rendered, with size/color/title props cloned into it
   * - If given a React element type, it will be rendered with the other icon props
   *   As a consumer, you should never use `<IconWrapper icon={<element />}` directly; simply render `<element />` instead.
   */
  icon: _propTypes["default"].oneOfType([_propTypes["default"].elementType, _propTypes["default"].element]),

  /**
   * Size of the icon, in pixels.
   * Icons contains 16px and 20px SVG icon paths,
   * and chooses the appropriate resolution based on this prop.
   */
  size: _propTypes["default"].number,

  /**
   * Description string.
   * Browsers usually render this as a tooltip on hover, whereas screen
   * readers will use it for aural feedback.
   * By default, this is set to the icon's name for accessibility.
   */
  title: _propTypes["default"].string
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9pY29ucy9zcmMvSWNvbldyYXBwZXIuanMiXSwibmFtZXMiOlsiSWNvbldyYXBwZXIiLCJJY29uIiwicmVmIiwiY29sb3IiLCJpY29uIiwic2l6ZSIsInRpdGxlIiwicHJvcHMiLCJpY29uUHJvcHMiLCJpY29uV2l0aFByb3BzIiwiUmVhY3RJcyIsImlzVmFsaWRFbGVtZW50VHlwZSIsIkNvbXBvbmVudCIsIlJlYWN0IiwiaXNWYWxpZEVsZW1lbnQiLCJjbG9uZUVsZW1lbnQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJzdHJpbmciLCJvbmVPZlR5cGUiLCJlbGVtZW50VHlwZSIsImVsZW1lbnQiLCJudW1iZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7Ozs7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sSUFBTUEsV0FBVyxnQkFBRywrQkFDekIsdUJBQVcsU0FBU0MsSUFBVCxPQUFzREMsR0FBdEQsRUFBMkQ7QUFBQSxNQUEzQ0MsS0FBMkMsUUFBM0NBLEtBQTJDO0FBQUEsTUFBcENDLElBQW9DLFFBQXBDQSxJQUFvQztBQUFBLE1BQTlCQyxJQUE4QixRQUE5QkEsSUFBOEI7QUFBQSxNQUF4QkMsS0FBd0IsUUFBeEJBLEtBQXdCO0FBQUEsTUFBZEMsS0FBYzs7QUFDcEUsTUFBSSxDQUFDSCxJQUFELElBQVMsT0FBT0EsSUFBUCxLQUFnQixRQUE3QixFQUF1QztBQUNyQyxXQUFPLElBQVA7QUFDRDs7QUFFRCxNQUFNSSxTQUFTLEdBQUc7QUFDaEJMLElBQUFBLEtBQUssRUFBTEEsS0FEZ0I7QUFFaEJFLElBQUFBLElBQUksRUFBSkEsSUFGZ0I7QUFHaEJDLElBQUFBLEtBQUssRUFBTEE7QUFIZ0IsR0FBbEI7QUFNQSxNQUFJRyxhQUFhLEdBQUcsSUFBcEI7O0FBQ0EsTUFBSUMsb0JBQVFDLGtCQUFSLENBQTJCUCxJQUEzQixDQUFKLEVBQXNDO0FBQ3BDLFFBQU1RLFNBQVMsR0FBR1IsSUFBbEI7QUFDQUssSUFBQUEsYUFBYSxnQkFBRyxnQ0FBQyxTQUFEO0FBQVcsTUFBQSxHQUFHLEVBQUVQO0FBQWhCLE9BQXlCTSxTQUF6QixFQUFoQjtBQUNELEdBSEQsTUFHTyxrQkFBSUssa0JBQU1DLGNBQU4sQ0FBcUJWLElBQXJCLENBQUosRUFBZ0M7QUFDckNLLElBQUFBLGFBQWEsZ0JBQUdJLGtCQUFNRSxZQUFOLENBQW1CWCxJQUFuQixnREFBOEJJLFNBQTlCLEdBQTRDSixJQUFJLENBQUNHLEtBQWpEO0FBQXdETCxNQUFBQSxHQUFHLEVBQUhBO0FBQXhELE9BQWhCO0FBQ0Q7O0FBRUQsc0JBQ0UsZ0NBQUMsaUJBQUQ7QUFBSyxJQUFBLE9BQU8sRUFBQztBQUFiLEtBQStCSyxLQUEvQixHQUNHRSxhQURILENBREY7QUFLRCxDQXhCRCxDQUR5QixDQUFwQjs7QUE0QlBULFdBQVcsQ0FBQ2dCLFNBQVosR0FBd0I7QUFDdEI7QUFDRjtBQUNBO0FBQ0ViLEVBQUFBLEtBQUssRUFBRWMsc0JBQVVDLE1BSks7O0FBTXRCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRWQsRUFBQUEsSUFBSSxFQUFFYSxzQkFBVUUsU0FBVixDQUFvQixDQUFDRixzQkFBVUcsV0FBWCxFQUF3Qkgsc0JBQVVJLE9BQWxDLENBQXBCLENBZGdCOztBQWdCdEI7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNFaEIsRUFBQUEsSUFBSSxFQUFFWSxzQkFBVUssTUFyQk07O0FBdUJ0QjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDRWhCLEVBQUFBLEtBQUssRUFBRVcsc0JBQVVDO0FBN0JLLENBQXhCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IGZvcndhcmRSZWYsIG1lbW8gfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBSZWFjdElzIGZyb20gJ3JlYWN0LWlzJ1xuaW1wb3J0IEJveCBmcm9tICd1aS1ib3gnXG5cbi8qKlxuICogVGhpcyBpcyBhbiBpbnRlcm5hbCBoZWxwZXIgY29tcG9uZW50IGZvciByZW5kZXJpbmcgY3VzdG9tIG9yIEV2ZXJncmVlbiBpY29uc1xuICogQm94IHByb3BzIGFyZSBhcHBsaWVkIHRvIHRoZSBvdXRlciBCb3ggY29udGFpbmVyLCBhbmQgRXZlcmdyZWVuIGljb24tc3BlY2lmaWMgcHJvcHMgYXJlIGFkZGVkIHRvIHRoZSBpY29uIGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBJY29uV3JhcHBlciA9IG1lbW8oXG4gIGZvcndhcmRSZWYoZnVuY3Rpb24gSWNvbih7IGNvbG9yLCBpY29uLCBzaXplLCB0aXRsZSwgLi4ucHJvcHMgfSwgcmVmKSB7XG4gICAgaWYgKCFpY29uIHx8IHR5cGVvZiBpY29uID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG5cbiAgICBjb25zdCBpY29uUHJvcHMgPSB7XG4gICAgICBjb2xvcixcbiAgICAgIHNpemUsXG4gICAgICB0aXRsZVxuICAgIH1cblxuICAgIGxldCBpY29uV2l0aFByb3BzID0gbnVsbFxuICAgIGlmIChSZWFjdElzLmlzVmFsaWRFbGVtZW50VHlwZShpY29uKSkge1xuICAgICAgY29uc3QgQ29tcG9uZW50ID0gaWNvblxuICAgICAgaWNvbldpdGhQcm9wcyA9IDxDb21wb25lbnQgcmVmPXtyZWZ9IHsuLi5pY29uUHJvcHN9IC8+XG4gICAgfSBlbHNlIGlmIChSZWFjdC5pc1ZhbGlkRWxlbWVudChpY29uKSkge1xuICAgICAgaWNvbldpdGhQcm9wcyA9IFJlYWN0LmNsb25lRWxlbWVudChpY29uLCB7IC4uLmljb25Qcm9wcywgLi4uaWNvbi5wcm9wcywgcmVmIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxCb3ggZGlzcGxheT1cImlubGluZS1mbGV4XCIgey4uLnByb3BzfT5cbiAgICAgICAge2ljb25XaXRoUHJvcHN9XG4gICAgICA8L0JveD5cbiAgICApXG4gIH0pXG4pXG5cbkljb25XcmFwcGVyLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIENvbG9yIG9mIGljb24uIEVxdWl2YWxlbnQgdG8gc2V0dGluZyBDU1MgYGZpbGxgIHByb3BlcnR5LlxuICAgKi9cbiAgY29sb3I6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBpY29uIGNvbXBvbmVudCAtIHdoZXRoZXIgYW4gRXZlcmdyZWVuIGljb24gb3IgYSBjdXN0b20gaWNvbiBub2RlOlxuICAgKlxuICAgKiAtIElmIGBudWxsYCBvciBgdW5kZWZpbmVkYCBvciBgZmFsc2VgLCB0aGlzIGNvbXBvbmVudCB3aWxsIHJlbmRlciBub3RoaW5nLlxuICAgKiAtIElmIGdpdmVuIGEgYEpTWC5FbGVtZW50YCwgdGhhdCBlbGVtZW50IHdpbGwgYmUgcmVuZGVyZWQsIHdpdGggc2l6ZS9jb2xvci90aXRsZSBwcm9wcyBjbG9uZWQgaW50byBpdFxuICAgKiAtIElmIGdpdmVuIGEgUmVhY3QgZWxlbWVudCB0eXBlLCBpdCB3aWxsIGJlIHJlbmRlcmVkIHdpdGggdGhlIG90aGVyIGljb24gcHJvcHNcbiAgICogICBBcyBhIGNvbnN1bWVyLCB5b3Ugc2hvdWxkIG5ldmVyIHVzZSBgPEljb25XcmFwcGVyIGljb249ezxlbGVtZW50IC8+fWAgZGlyZWN0bHk7IHNpbXBseSByZW5kZXIgYDxlbGVtZW50IC8+YCBpbnN0ZWFkLlxuICAgKi9cbiAgaWNvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnRUeXBlLCBQcm9wVHlwZXMuZWxlbWVudF0pLFxuXG4gIC8qKlxuICAgKiBTaXplIG9mIHRoZSBpY29uLCBpbiBwaXhlbHMuXG4gICAqIEljb25zIGNvbnRhaW5zIDE2cHggYW5kIDIwcHggU1ZHIGljb24gcGF0aHMsXG4gICAqIGFuZCBjaG9vc2VzIHRoZSBhcHByb3ByaWF0ZSByZXNvbHV0aW9uIGJhc2VkIG9uIHRoaXMgcHJvcC5cbiAgICovXG4gIHNpemU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIERlc2NyaXB0aW9uIHN0cmluZy5cbiAgICogQnJvd3NlcnMgdXN1YWxseSByZW5kZXIgdGhpcyBhcyBhIHRvb2x0aXAgb24gaG92ZXIsIHdoZXJlYXMgc2NyZWVuXG4gICAqIHJlYWRlcnMgd2lsbCB1c2UgaXQgZm9yIGF1cmFsIGZlZWRiYWNrLlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGlzIHNldCB0byB0aGUgaWNvbidzIG5hbWUgZm9yIGFjY2Vzc2liaWxpdHkuXG4gICAqL1xuICB0aXRsZTogUHJvcFR5cGVzLnN0cmluZ1xufVxuIl19
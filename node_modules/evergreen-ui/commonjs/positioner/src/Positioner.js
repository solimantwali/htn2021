"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _typeof = require("@babel/runtime/helpers/typeof");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _reactTransitionGroup = require("react-transition-group");

var _constants = require("../../constants");

var _hooks = require("../../hooks");

var _portal = require("../../portal");

var _stack = require("../../stack");

var _getPosition2 = _interopRequireDefault(require("./getPosition"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var animationEasing = {
  spring: 'cubic-bezier(0.175, 0.885, 0.320, 1.175)'
};

var getCSS = function getCSS(_ref) {
  var animationDuration = _ref.animationDuration,
      initialScale = _ref.initialScale;
  return {
    position: 'fixed',
    opacity: 0,
    transitionTimingFunction: animationEasing.spring,
    transitionDuration: "".concat(animationDuration, "ms"),
    transitionProperty: 'opacity, transform',
    transform: "scale(".concat(initialScale, ") translateY(-1px)"),
    '&[data-state="entering"], &[data-state="entered"]': {
      opacity: 1,
      visibility: 'visible',
      transform: 'scale(1)'
    },
    '&[data-state="exiting"]': {
      opacity: 0,
      transform: 'scale(1)'
    }
  };
};

var noop = function noop() {};

var initialDimensions = {
  left: 0,
  top: 0,
  height: 0,
  width: 0,
  transformOrigin: null
};
var Positioner = /*#__PURE__*/(0, _react.memo)(function Positioner(props) {
  var target = props.target,
      isShown = props.isShown,
      children = props.children,
      _props$initialScale = props.initialScale,
      initialScale = _props$initialScale === void 0 ? 0.9 : _props$initialScale,
      _props$animationDurat = props.animationDuration,
      animationDuration = _props$animationDurat === void 0 ? 300 : _props$animationDurat,
      _props$position = props.position,
      position = _props$position === void 0 ? _constants.Position.BOTTOM : _props$position,
      _props$bodyOffset = props.bodyOffset,
      bodyOffset = _props$bodyOffset === void 0 ? 6 : _props$bodyOffset,
      _props$targetOffset = props.targetOffset,
      targetOffset = _props$targetOffset === void 0 ? 6 : _props$targetOffset,
      _props$onOpenComplete = props.onOpenComplete,
      onOpenComplete = _props$onOpenComplete === void 0 ? noop : _props$onOpenComplete,
      _props$onCloseComplet = props.onCloseComplete,
      onCloseComplete = _props$onCloseComplet === void 0 ? noop : _props$onCloseComplet;

  var _useState = (0, _react.useState)(initialDimensions),
      _useState2 = (0, _slicedToArray2["default"])(_useState, 2),
      dimensions = _useState2[0],
      setDimensions = _useState2[1];

  var previousDimensions = (0, _hooks.usePrevious)(dimensions, initialDimensions);
  var latestAnimationFrame = (0, _react.useRef)();
  var transitionState = (0, _react.useRef)();
  var positionerRef = (0, _react.useRef)();
  var targetRef = (0, _react.useRef)();
  var setTargetRef = (0, _hooks.useMergedRef)(targetRef);
  var getRef = (0, _hooks.useMergedRef)(positionerRef); // Call `update` whenever the component has "entered" and dimensions change

  (0, _react.useEffect)(function () {
    if (transitionState.current === 'entered') {
      latestAnimationFrame.current = requestAnimationFrame(function () {
        update(previousDimensions.height, previousDimensions.width);
      });
    }

    return function () {
      if (latestAnimationFrame.current) {
        cancelAnimationFrame(latestAnimationFrame.current);
      }
    };
  }, [dimensions]);

  var handleEnter = function handleEnter() {
    transitionState.current = 'entered';
    update();
  };

  var update = function update() {
    var prevHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var prevWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!isShown || !targetRef.current || !positionerRef.current) return;
    var targetRect = targetRef.current.getBoundingClientRect();
    var hasEntered = positionerRef.current.getAttribute('data-state') === 'entered';
    var viewportHeight = document.documentElement.clientHeight;
    var viewportWidth = document.documentElement.clientWidth;
    var height;
    var width;

    if (hasEntered) {
      // Only when the animation is done should we opt-in to `getBoundingClientRect`
      var positionerRect = positionerRef.current.getBoundingClientRect(); // https://github.com/segmentio/evergreen/issues/255
      // We need to ceil the width and height to prevent jitter when
      // the window is zoomed (when `window.devicePixelRatio` is not an integer)

      height = Math.round(positionerRect.height);
      width = Math.round(positionerRect.width);
    } else {
      // When the animation is in flight use `offsetWidth/Height` which
      // does not calculate the `transform` property as part of its result.
      // There is still change on jitter during the animation (although unoticable)
      // When the browser is zoomed in â€” we fix this with `Math.max`.
      height = Math.max(positionerRef.current.offsetHeight, prevHeight);
      width = Math.max(positionerRef.current.offsetWidth, prevWidth);
    }

    var _getPosition = (0, _getPosition2["default"])({
      position: position,
      targetRect: targetRect,
      targetOffset: targetOffset,
      dimensions: {
        height: height,
        width: width
      },
      viewport: {
        width: viewportWidth,
        height: viewportHeight
      },
      viewportOffset: bodyOffset
    }),
        rect = _getPosition.rect,
        transformOrigin = _getPosition.transformOrigin;

    setDimensions({
      left: rect.left,
      top: rect.top,
      height: height,
      width: width,
      transformOrigin: transformOrigin
    });
  };

  var handleExited = function handleExited() {
    transitionState.current = 'exited';
    setDimensions(initialDimensions);
    onCloseComplete();
  };

  return /*#__PURE__*/_react["default"].createElement(_stack.Stack, {
    value: _constants.StackingOrder.POSITIONER
  }, function (zIndex) {
    return /*#__PURE__*/_react["default"].createElement(_react["default"].Fragment, null, target({
      getRef: setTargetRef,
      isShown: isShown
    }), /*#__PURE__*/_react["default"].createElement(_reactTransitionGroup.Transition, {
      nodeRef: positionerRef,
      appear: true,
      "in": isShown,
      timeout: animationDuration,
      onEnter: handleEnter,
      onEntered: onOpenComplete,
      onExited: handleExited,
      unmountOnExit: true
    }, function (state) {
      return /*#__PURE__*/_react["default"].createElement(_portal.Portal, null, children({
        top: dimensions.top,
        left: dimensions.left,
        state: state,
        zIndex: zIndex,
        css: getCSS({
          initialScale: initialScale,
          animationDuration: animationDuration
        }),
        style: {
          transformOrigin: dimensions.transformOrigin,
          left: dimensions.left,
          top: dimensions.top,
          zIndex: zIndex
        },
        getRef: getRef,
        animationDuration: animationDuration
      }));
    }));
  });
});
Positioner.propTypes = {
  /**
   * The position the element that is being positioned is on.
   * Smart positioning might override this.
   */
  position: _propTypes["default"].oneOf([_constants.Position.TOP, _constants.Position.TOP_LEFT, _constants.Position.TOP_RIGHT, _constants.Position.BOTTOM, _constants.Position.BOTTOM_LEFT, _constants.Position.BOTTOM_RIGHT, _constants.Position.LEFT, _constants.Position.RIGHT]),

  /**
   * When true, show the element being positioned.
   */
  isShown: _propTypes["default"].bool,

  /**
   * Function that returns the element being positioned.
   */
  children: _propTypes["default"].func.isRequired,

  /**
   * The minimum distance from the body to the element being positioned.
   */
  bodyOffset: _propTypes["default"].number,

  /**
   * The minimum distance from the target to the element being positioned.
   */
  targetOffset: _propTypes["default"].number,

  /**
   * Function that should return a node for the target.
   * ({ getRef: () -> Ref, isShown: Bool }) -> React Node
   */
  target: _propTypes["default"].func.isRequired,

  /**
   * Initial scale of the element being positioned.
   */
  initialScale: _propTypes["default"].number,

  /**
   * Duration of the animation.
   */
  animationDuration: _propTypes["default"].number,

  /**
   * Function that will be called when the exit transition is complete.
   */
  onCloseComplete: _propTypes["default"].func,

  /**
   * Function that will be called when the enter transition is complete.
   */
  onOpenComplete: _propTypes["default"].func
};
var _default = Positioner;
exports["default"] = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3NpdGlvbmVyL3NyYy9Qb3NpdGlvbmVyLmpzIl0sIm5hbWVzIjpbImFuaW1hdGlvbkVhc2luZyIsInNwcmluZyIsImdldENTUyIsImFuaW1hdGlvbkR1cmF0aW9uIiwiaW5pdGlhbFNjYWxlIiwicG9zaXRpb24iLCJvcGFjaXR5IiwidHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvblByb3BlcnR5IiwidHJhbnNmb3JtIiwidmlzaWJpbGl0eSIsIm5vb3AiLCJpbml0aWFsRGltZW5zaW9ucyIsImxlZnQiLCJ0b3AiLCJoZWlnaHQiLCJ3aWR0aCIsInRyYW5zZm9ybU9yaWdpbiIsIlBvc2l0aW9uZXIiLCJwcm9wcyIsInRhcmdldCIsImlzU2hvd24iLCJjaGlsZHJlbiIsIlBvc2l0aW9uIiwiQk9UVE9NIiwiYm9keU9mZnNldCIsInRhcmdldE9mZnNldCIsIm9uT3BlbkNvbXBsZXRlIiwib25DbG9zZUNvbXBsZXRlIiwiZGltZW5zaW9ucyIsInNldERpbWVuc2lvbnMiLCJwcmV2aW91c0RpbWVuc2lvbnMiLCJsYXRlc3RBbmltYXRpb25GcmFtZSIsInRyYW5zaXRpb25TdGF0ZSIsInBvc2l0aW9uZXJSZWYiLCJ0YXJnZXRSZWYiLCJzZXRUYXJnZXRSZWYiLCJnZXRSZWYiLCJjdXJyZW50IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidXBkYXRlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJoYW5kbGVFbnRlciIsInByZXZIZWlnaHQiLCJwcmV2V2lkdGgiLCJ0YXJnZXRSZWN0IiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwiaGFzRW50ZXJlZCIsImdldEF0dHJpYnV0ZSIsInZpZXdwb3J0SGVpZ2h0IiwiZG9jdW1lbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJjbGllbnRIZWlnaHQiLCJ2aWV3cG9ydFdpZHRoIiwiY2xpZW50V2lkdGgiLCJwb3NpdGlvbmVyUmVjdCIsIk1hdGgiLCJyb3VuZCIsIm1heCIsIm9mZnNldEhlaWdodCIsIm9mZnNldFdpZHRoIiwidmlld3BvcnQiLCJ2aWV3cG9ydE9mZnNldCIsInJlY3QiLCJoYW5kbGVFeGl0ZWQiLCJTdGFja2luZ09yZGVyIiwiUE9TSVRJT05FUiIsInpJbmRleCIsInN0YXRlIiwiY3NzIiwic3R5bGUiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJvbmVPZiIsIlRPUCIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiQk9UVE9NX0xFRlQiLCJCT1RUT01fUklHSFQiLCJMRUZUIiwiUklHSFQiLCJib29sIiwiZnVuYyIsImlzUmVxdWlyZWQiLCJudW1iZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTUEsZUFBZSxHQUFHO0FBQ3RCQyxFQUFBQSxNQUFNLEVBQUU7QUFEYyxDQUF4Qjs7QUFJQSxJQUFNQyxNQUFNLEdBQUcsU0FBVEEsTUFBUztBQUFBLE1BQUdDLGlCQUFILFFBQUdBLGlCQUFIO0FBQUEsTUFBc0JDLFlBQXRCLFFBQXNCQSxZQUF0QjtBQUFBLFNBQTBDO0FBQ3ZEQyxJQUFBQSxRQUFRLEVBQUUsT0FENkM7QUFFdkRDLElBQUFBLE9BQU8sRUFBRSxDQUY4QztBQUd2REMsSUFBQUEsd0JBQXdCLEVBQUVQLGVBQWUsQ0FBQ0MsTUFIYTtBQUl2RE8sSUFBQUEsa0JBQWtCLFlBQUtMLGlCQUFMLE9BSnFDO0FBS3ZETSxJQUFBQSxrQkFBa0IsRUFBRSxvQkFMbUM7QUFNdkRDLElBQUFBLFNBQVMsa0JBQVdOLFlBQVgsdUJBTjhDO0FBT3ZELHlEQUFxRDtBQUNuREUsTUFBQUEsT0FBTyxFQUFFLENBRDBDO0FBRW5ESyxNQUFBQSxVQUFVLEVBQUUsU0FGdUM7QUFHbkRELE1BQUFBLFNBQVMsRUFBRTtBQUh3QyxLQVBFO0FBWXZELCtCQUEyQjtBQUN6QkosTUFBQUEsT0FBTyxFQUFFLENBRGdCO0FBRXpCSSxNQUFBQSxT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RCxTQUhlLEVBSXhCckQsb0JBQVNDLE1BSmUsRUFLeEJELG9CQUFTc0QsV0FMZSxFQU14QnRELG9CQUFTdUQsWUFOZSxFQU94QnZELG9CQUFTd0QsSUFQZSxFQVF4QnhELG9CQUFTeUQsS0FSZSxDQUFoQixDQUxXOztBQWdCckI7QUFDRjtBQUNBO0FBQ0UzRCxFQUFBQSxPQUFPLEVBQUVtRCxzQkFBVVMsSUFuQkU7O0FBcUJyQjtBQUNGO0FBQ0E7QUFDRTNELEVBQUFBLFFBQVEsRUFBRWtELHNCQUFVVSxJQUFWLENBQWVDLFVBeEJKOztBQTBCckI7QUFDRjtBQUNBO0FBQ0UxRCxFQUFBQSxVQUFVLEVBQUUrQyxzQkFBVVksTUE3QkQ7O0FBK0JyQjtBQUNGO0FBQ0E7QUFDRTFELEVBQUFBLFlBQVksRUFBRThDLHNCQUFVWSxNQWxDSDs7QUFvQ3JCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0VoRSxFQUFBQSxNQUFNLEVBQUVvRCxzQkFBVVUsSUFBVixDQUFlQyxVQXhDRjs7QUEwQ3JCO0FBQ0Y7QUFDQTtBQUNFaEYsRUFBQUEsWUFBWSxFQUFFcUUsc0JBQVVZLE1BN0NIOztBQStDckI7QUFDRjtBQUNBO0FBQ0VsRixFQUFBQSxpQkFBaUIsRUFBRXNFLHNCQUFVWSxNQWxEUjs7QUFvRHJCO0FBQ0Y7QUFDQTtBQUNFeEQsRUFBQUEsZUFBZSxFQUFFNEMsc0JBQVVVLElBdkROOztBQXlEckI7QUFDRjtBQUNBO0FBQ0V2RCxFQUFBQSxjQUFjLEVBQUU2QyxzQkFBVVU7QUE1REwsQ0FBdkI7ZUErRGVoRSxVIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IG1lbW8sIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IHsgVHJhbnNpdGlvbiB9IGZyb20gJ3JlYWN0LXRyYW5zaXRpb24tZ3JvdXAnXG5pbXBvcnQgeyBTdGFja2luZ09yZGVyLCBQb3NpdGlvbiB9IGZyb20gJy4uLy4uL2NvbnN0YW50cydcbmltcG9ydCB7IHVzZU1lcmdlZFJlZiwgdXNlUHJldmlvdXMgfSBmcm9tICcuLi8uLi9ob29rcydcbmltcG9ydCB7IFBvcnRhbCB9IGZyb20gJy4uLy4uL3BvcnRhbCdcbmltcG9ydCB7IFN0YWNrIH0gZnJvbSAnLi4vLi4vc3RhY2snXG5pbXBvcnQgZ2V0UG9zaXRpb24gZnJvbSAnLi9nZXRQb3NpdGlvbidcblxuY29uc3QgYW5pbWF0aW9uRWFzaW5nID0ge1xuICBzcHJpbmc6ICdjdWJpYy1iZXppZXIoMC4xNzUsIDAuODg1LCAwLjMyMCwgMS4xNzUpJ1xufVxuXG5jb25zdCBnZXRDU1MgPSAoeyBhbmltYXRpb25EdXJhdGlvbiwgaW5pdGlhbFNjYWxlIH0pID0+ICh7XG4gIHBvc2l0aW9uOiAnZml4ZWQnLFxuICBvcGFjaXR5OiAwLFxuICB0cmFuc2l0aW9uVGltaW5nRnVuY3Rpb246IGFuaW1hdGlvbkVhc2luZy5zcHJpbmcsXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogYCR7YW5pbWF0aW9uRHVyYXRpb259bXNgLFxuICB0cmFuc2l0aW9uUHJvcGVydHk6ICdvcGFjaXR5LCB0cmFuc2Zvcm0nLFxuICB0cmFuc2Zvcm06IGBzY2FsZSgke2luaXRpYWxTY2FsZX0pIHRyYW5zbGF0ZVkoLTFweClgLFxuICAnJltkYXRhLXN0YXRlPVwiZW50ZXJpbmdcIl0sICZbZGF0YS1zdGF0ZT1cImVudGVyZWRcIl0nOiB7XG4gICAgb3BhY2l0eTogMSxcbiAgICB2aXNpYmlsaXR5OiAndmlzaWJsZScsXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknXG4gIH0sXG4gICcmW2RhdGEtc3RhdGU9XCJleGl0aW5nXCJdJzoge1xuICAgIG9wYWNpdHk6IDAsXG4gICAgdHJhbnNmb3JtOiAnc2NhbGUoMSknXG4gIH1cbn0pXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuY29uc3QgaW5pdGlhbERpbWVuc2lvbnMgPSB7XG4gIGxlZnQ6IDAsXG4gIHRvcDogMCxcbiAgaGVpZ2h0OiAwLFxuICB3aWR0aDogMCxcbiAgdHJhbnNmb3JtT3JpZ2luOiBudWxsXG59XG5cbmNvbnN0IFBvc2l0aW9uZXIgPSBtZW1vKGZ1bmN0aW9uIFBvc2l0aW9uZXIocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHRhcmdldCxcbiAgICBpc1Nob3duLFxuICAgIGNoaWxkcmVuLFxuICAgIGluaXRpYWxTY2FsZSA9IDAuOSxcbiAgICBhbmltYXRpb25EdXJhdGlvbiA9IDMwMCxcbiAgICBwb3NpdGlvbiA9IFBvc2l0aW9uLkJPVFRPTSxcbiAgICBib2R5T2Zmc2V0ID0gNixcbiAgICB0YXJnZXRPZmZzZXQgPSA2LFxuICAgIG9uT3BlbkNvbXBsZXRlID0gbm9vcCxcbiAgICBvbkNsb3NlQ29tcGxldGUgPSBub29wXG4gIH0gPSBwcm9wc1xuXG4gIGNvbnN0IFtkaW1lbnNpb25zLCBzZXREaW1lbnNpb25zXSA9IHVzZVN0YXRlKGluaXRpYWxEaW1lbnNpb25zKVxuICBjb25zdCBwcmV2aW91c0RpbWVuc2lvbnMgPSB1c2VQcmV2aW91cyhkaW1lbnNpb25zLCBpbml0aWFsRGltZW5zaW9ucylcbiAgY29uc3QgbGF0ZXN0QW5pbWF0aW9uRnJhbWUgPSB1c2VSZWYoKVxuICBjb25zdCB0cmFuc2l0aW9uU3RhdGUgPSB1c2VSZWYoKVxuICBjb25zdCBwb3NpdGlvbmVyUmVmID0gdXNlUmVmKClcbiAgY29uc3QgdGFyZ2V0UmVmID0gdXNlUmVmKClcbiAgY29uc3Qgc2V0VGFyZ2V0UmVmID0gdXNlTWVyZ2VkUmVmKHRhcmdldFJlZilcbiAgY29uc3QgZ2V0UmVmID0gdXNlTWVyZ2VkUmVmKHBvc2l0aW9uZXJSZWYpXG5cbiAgLy8gQ2FsbCBgdXBkYXRlYCB3aGVuZXZlciB0aGUgY29tcG9uZW50IGhhcyBcImVudGVyZWRcIiBhbmQgZGltZW5zaW9ucyBjaGFuZ2VcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAodHJhbnNpdGlvblN0YXRlLmN1cnJlbnQgPT09ICdlbnRlcmVkJykge1xuICAgICAgbGF0ZXN0QW5pbWF0aW9uRnJhbWUuY3VycmVudCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHVwZGF0ZShwcmV2aW91c0RpbWVuc2lvbnMuaGVpZ2h0LCBwcmV2aW91c0RpbWVuc2lvbnMud2lkdGgpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZiAobGF0ZXN0QW5pbWF0aW9uRnJhbWUuY3VycmVudCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShsYXRlc3RBbmltYXRpb25GcmFtZS5jdXJyZW50KVxuICAgICAgfVxuICAgIH1cbiAgfSwgW2RpbWVuc2lvbnNdKVxuXG4gIGNvbnN0IGhhbmRsZUVudGVyID0gKCkgPT4ge1xuICAgIHRyYW5zaXRpb25TdGF0ZS5jdXJyZW50ID0gJ2VudGVyZWQnXG4gICAgdXBkYXRlKClcbiAgfVxuXG4gIGNvbnN0IHVwZGF0ZSA9IChwcmV2SGVpZ2h0ID0gMCwgcHJldldpZHRoID0gMCkgPT4ge1xuICAgIGlmICghaXNTaG93biB8fCAhdGFyZ2V0UmVmLmN1cnJlbnQgfHwgIXBvc2l0aW9uZXJSZWYuY3VycmVudCkgcmV0dXJuXG5cbiAgICBjb25zdCB0YXJnZXRSZWN0ID0gdGFyZ2V0UmVmLmN1cnJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcblxuICAgIGNvbnN0IGhhc0VudGVyZWQgPSBwb3NpdGlvbmVyUmVmLmN1cnJlbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXN0YXRlJykgPT09ICdlbnRlcmVkJ1xuXG4gICAgY29uc3Qgdmlld3BvcnRIZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0XG4gICAgY29uc3Qgdmlld3BvcnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aFxuXG4gICAgbGV0IGhlaWdodFxuICAgIGxldCB3aWR0aFxuICAgIGlmIChoYXNFbnRlcmVkKSB7XG4gICAgICAvLyBPbmx5IHdoZW4gdGhlIGFuaW1hdGlvbiBpcyBkb25lIHNob3VsZCB3ZSBvcHQtaW4gdG8gYGdldEJvdW5kaW5nQ2xpZW50UmVjdGBcbiAgICAgIGNvbnN0IHBvc2l0aW9uZXJSZWN0ID0gcG9zaXRpb25lclJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zZWdtZW50aW8vZXZlcmdyZWVuL2lzc3Vlcy8yNTVcbiAgICAgIC8vIFdlIG5lZWQgdG8gY2VpbCB0aGUgd2lkdGggYW5kIGhlaWdodCB0byBwcmV2ZW50IGppdHRlciB3aGVuXG4gICAgICAvLyB0aGUgd2luZG93IGlzIHpvb21lZCAod2hlbiBgd2luZG93LmRldmljZVBpeGVsUmF0aW9gIGlzIG5vdCBhbiBpbnRlZ2VyKVxuICAgICAgaGVpZ2h0ID0gTWF0aC5yb3VuZChwb3NpdGlvbmVyUmVjdC5oZWlnaHQpXG4gICAgICB3aWR0aCA9IE1hdGgucm91bmQocG9zaXRpb25lclJlY3Qud2lkdGgpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdoZW4gdGhlIGFuaW1hdGlvbiBpcyBpbiBmbGlnaHQgdXNlIGBvZmZzZXRXaWR0aC9IZWlnaHRgIHdoaWNoXG4gICAgICAvLyBkb2VzIG5vdCBjYWxjdWxhdGUgdGhlIGB0cmFuc2Zvcm1gIHByb3BlcnR5IGFzIHBhcnQgb2YgaXRzIHJlc3VsdC5cbiAgICAgIC8vIFRoZXJlIGlzIHN0aWxsIGNoYW5nZSBvbiBqaXR0ZXIgZHVyaW5nIHRoZSBhbmltYXRpb24gKGFsdGhvdWdoIHVub3RpY2FibGUpXG4gICAgICAvLyBXaGVuIHRoZSBicm93c2VyIGlzIHpvb21lZCBpbiDigJQgd2UgZml4IHRoaXMgd2l0aCBgTWF0aC5tYXhgLlxuICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgocG9zaXRpb25lclJlZi5jdXJyZW50Lm9mZnNldEhlaWdodCwgcHJldkhlaWdodClcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgocG9zaXRpb25lclJlZi5jdXJyZW50Lm9mZnNldFdpZHRoLCBwcmV2V2lkdGgpXG4gICAgfVxuXG4gICAgY29uc3QgeyByZWN0LCB0cmFuc2Zvcm1PcmlnaW4gfSA9IGdldFBvc2l0aW9uKHtcbiAgICAgIHBvc2l0aW9uLFxuICAgICAgdGFyZ2V0UmVjdCxcbiAgICAgIHRhcmdldE9mZnNldCxcbiAgICAgIGRpbWVuc2lvbnM6IHtcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICB3aWR0aFxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHdpZHRoOiB2aWV3cG9ydFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IHZpZXdwb3J0SGVpZ2h0XG4gICAgICB9LFxuICAgICAgdmlld3BvcnRPZmZzZXQ6IGJvZHlPZmZzZXRcbiAgICB9KVxuXG4gICAgc2V0RGltZW5zaW9ucyh7XG4gICAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgICB0b3A6IHJlY3QudG9wLFxuICAgICAgaGVpZ2h0LFxuICAgICAgd2lkdGgsXG4gICAgICB0cmFuc2Zvcm1PcmlnaW5cbiAgICB9KVxuICB9XG5cbiAgY29uc3QgaGFuZGxlRXhpdGVkID0gKCkgPT4ge1xuICAgIHRyYW5zaXRpb25TdGF0ZS5jdXJyZW50ID0gJ2V4aXRlZCdcbiAgICBzZXREaW1lbnNpb25zKGluaXRpYWxEaW1lbnNpb25zKVxuICAgIG9uQ2xvc2VDb21wbGV0ZSgpXG4gIH1cblxuICByZXR1cm4gKFxuICAgIDxTdGFjayB2YWx1ZT17U3RhY2tpbmdPcmRlci5QT1NJVElPTkVSfT5cbiAgICAgIHt6SW5kZXggPT4ge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIDxSZWFjdC5GcmFnbWVudD5cbiAgICAgICAgICAgIHt0YXJnZXQoeyBnZXRSZWY6IHNldFRhcmdldFJlZiwgaXNTaG93biB9KX1cblxuICAgICAgICAgICAgPFRyYW5zaXRpb25cbiAgICAgICAgICAgICAgbm9kZVJlZj17cG9zaXRpb25lclJlZn1cbiAgICAgICAgICAgICAgYXBwZWFyXG4gICAgICAgICAgICAgIGluPXtpc1Nob3dufVxuICAgICAgICAgICAgICB0aW1lb3V0PXthbmltYXRpb25EdXJhdGlvbn1cbiAgICAgICAgICAgICAgb25FbnRlcj17aGFuZGxlRW50ZXJ9XG4gICAgICAgICAgICAgIG9uRW50ZXJlZD17b25PcGVuQ29tcGxldGV9XG4gICAgICAgICAgICAgIG9uRXhpdGVkPXtoYW5kbGVFeGl0ZWR9XG4gICAgICAgICAgICAgIHVubW91bnRPbkV4aXRcbiAgICAgICAgICAgID5cbiAgICAgICAgICAgICAge3N0YXRlID0+IChcbiAgICAgICAgICAgICAgICA8UG9ydGFsPlxuICAgICAgICAgICAgICAgICAge2NoaWxkcmVuKHtcbiAgICAgICAgICAgICAgICAgICAgdG9wOiBkaW1lbnNpb25zLnRvcCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZGltZW5zaW9ucy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgekluZGV4LFxuICAgICAgICAgICAgICAgICAgICBjc3M6IGdldENTUyh7XG4gICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbFNjYWxlLFxuICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjogZGltZW5zaW9ucy50cmFuc2Zvcm1PcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgbGVmdDogZGltZW5zaW9ucy5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgIHRvcDogZGltZW5zaW9ucy50b3AsXG4gICAgICAgICAgICAgICAgICAgICAgekluZGV4XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldFJlZixcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRHVyYXRpb25cbiAgICAgICAgICAgICAgICAgIH0pfVxuICAgICAgICAgICAgICAgIDwvUG9ydGFsPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9UcmFuc2l0aW9uPlxuICAgICAgICAgIDwvUmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgIClcbiAgICAgIH19XG4gICAgPC9TdGFjaz5cbiAgKVxufSlcblxuUG9zaXRpb25lci5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBUaGUgcG9zaXRpb24gdGhlIGVsZW1lbnQgdGhhdCBpcyBiZWluZyBwb3NpdGlvbmVkIGlzIG9uLlxuICAgKiBTbWFydCBwb3NpdGlvbmluZyBtaWdodCBvdmVycmlkZSB0aGlzLlxuICAgKi9cbiAgcG9zaXRpb246IFByb3BUeXBlcy5vbmVPZihbXG4gICAgUG9zaXRpb24uVE9QLFxuICAgIFBvc2l0aW9uLlRPUF9MRUZULFxuICAgIFBvc2l0aW9uLlRPUF9SSUdIVCxcbiAgICBQb3NpdGlvbi5CT1RUT00sXG4gICAgUG9zaXRpb24uQk9UVE9NX0xFRlQsXG4gICAgUG9zaXRpb24uQk9UVE9NX1JJR0hULFxuICAgIFBvc2l0aW9uLkxFRlQsXG4gICAgUG9zaXRpb24uUklHSFRcbiAgXSksXG5cbiAgLyoqXG4gICAqIFdoZW4gdHJ1ZSwgc2hvdyB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICAgKi9cbiAgaXNTaG93bjogUHJvcFR5cGVzLmJvb2wsXG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGRpc3RhbmNlIGZyb20gdGhlIGJvZHkgdG8gdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICovXG4gIGJvZHlPZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGRpc3RhbmNlIGZyb20gdGhlIHRhcmdldCB0byB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxuICAgKi9cbiAgdGFyZ2V0T2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHNob3VsZCByZXR1cm4gYSBub2RlIGZvciB0aGUgdGFyZ2V0LlxuICAgKiAoeyBnZXRSZWY6ICgpIC0+IFJlZiwgaXNTaG93bjogQm9vbCB9KSAtPiBSZWFjdCBOb2RlXG4gICAqL1xuICB0YXJnZXQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG5cbiAgLyoqXG4gICAqIEluaXRpYWwgc2NhbGUgb2YgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICovXG4gIGluaXRpYWxTY2FsZTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICovXG4gIGFuaW1hdGlvbkR1cmF0aW9uOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGV4aXQgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICovXG4gIG9uQ2xvc2VDb21wbGV0ZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBjYWxsZWQgd2hlbiB0aGUgZW50ZXIgdHJhbnNpdGlvbiBpcyBjb21wbGV0ZS5cbiAgICovXG4gIG9uT3BlbkNvbXBsZXRlOiBQcm9wVHlwZXMuZnVuY1xufVxuXG5leHBvcnQgZGVmYXVsdCBQb3NpdGlvbmVyXG4iXX0=
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useStyleConfig = useStyleConfig;

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _react = require("react");

var _glamor = require("glamor");

var _lodash = _interopRequireDefault(require("lodash.merge"));

var _reactFastCompare = _interopRequireDefault(require("react-fast-compare"));

var _uiBox = require("ui-box");

var _theme = require("../theme");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * @typedef {object} StateStyles
 * @property {import('csstype').Properties} [_hover]
 * @property {import('csstype').Properties} [_active]
 * @property {import('csstype').Properties} [_disabled]
 * @property {import('csstype').Properties} [_focus]
 * @property {import('csstype').Properties} [_invalid]
 */

/**
 * @typedef {{ [placeholder in keyof StateStyles]: string }} PseudoSelectors
 */

/**
 * @typedef {object} StyleModifiers
 * @property {string} [appearance]
 * @property {string} [size]
 */

/** @typedef {import('ui-box').EnhancerProps & StateStyles} Style */

/** @typedef {import('ui-box').EnhancerProps & import('glamor').CSSProperties} GlamorAndBoxStyle */

/**
 * @typedef {object} StyleConfig
 * @property {Style} baseStyle
 * @property {{ [appearance: string]: Style }} [appearances]
 * @property {{ [size: string]: Style }} [sizes]
 */
function maybeRun(value) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  return typeof value === 'function' ? value.apply(void 0, args) : value;
}

function maybeRunDeep(raw) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }

  if (raw && (0, _typeof2["default"])(raw) === 'object') {
    var result = {};

    for (var _i = 0, _Object$keys = Object.keys(raw); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      result[key] = maybeRunDeep.apply(void 0, [raw[key]].concat(args));
    }

    return result;
  }

  return maybeRun.apply(void 0, [raw].concat(args));
}
/**
 * Combines styles from a styleConfig, with the given style modifiers (appearance, size, etc) and internal styles
 * @param {object} theme
 * @param {StyleModifiers} props
 * @param {StyleConfig} styleConfig
 * @param {GlamorAndBoxStyle} [internalStyles]
 * @returns {StyleConfig}
 */


function combineStyles(theme, props, styleConfig) {
  var internalStyles = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var config = maybeRun(styleConfig, theme, props);
  var baseStyle = maybeRunDeep(config.baseStyle, theme, props);
  var sizeStyle = maybeRunDeep((0, _theme.get)(config, "sizes.".concat(props.size), {}), theme, props);
  var appearanceStyle = maybeRunDeep((0, _theme.get)(config, "appearances.".concat(props.appearance), {}), theme, props);
  return (0, _lodash["default"])({}, internalStyles, baseStyle, sizeStyle, appearanceStyle);
}
/**
 * Combines a styleConfig object with internal styles based on the theme + style modifiers (props)
 * and returns a memoized style object
 * @returns {StyleConfig}
 */


function useMergedStyles(theme, props, styleConfig, internalStyles) {
  var styleRef = (0, _react.useRef)({});
  return (0, _react.useMemo)(function () {
    var combinedStyles = combineStyles(theme, props, styleConfig, internalStyles);

    if (!(0, _reactFastCompare["default"])(styleRef.current, combinedStyles)) {
      styleRef.current = combinedStyles;
    }

    return styleRef.current;
  }, [theme, props, styleConfig, internalStyles]);
}
/**
 * Split up the style props into glamor-ready and box-ready props (className + spreadable props)
 */


function useGlamorAndBox(styles, pseudoSelectors) {
  var glamorStylesRef = (0, _react.useRef)({});
  var classNameRef = (0, _react.useRef)();
  return (0, _react.useMemo)(function () {
    // Split the resulting style object into ui-box-compatible props and the rest
    var _splitBoxProps = (0, _uiBox.splitBoxProps)(styles),
        matchedProps = _splitBoxProps.matchedProps,
        remainingProps = _splitBoxProps.remainingProps;
    /** @type {GlamorAndBoxStyle} */


    var glamorStyles = {}; // Swap out pseudo selector placeholders for their actual css selector strings

    for (var _i2 = 0, _Object$keys2 = Object.keys(remainingProps); _i2 < _Object$keys2.length; _i2++) {
      var k = _Object$keys2[_i2];
      var key = k in pseudoSelectors ? pseudoSelectors[k] : k;
      glamorStyles[key] = remainingProps[k];
    } // Take all the "non-compatible" props and give those to glamor (since ui-box doesn't know how to handle them yet)


    if (!(0, _reactFastCompare["default"])(glamorStylesRef.current, glamorStyles)) {
      var className = (0, _glamor.css)(glamorStyles).toString();
      glamorStylesRef.current = glamorStyles;
      classNameRef.current = className === 'css-nil' ? undefined : className;
    }

    return _objectSpread({
      className: classNameRef.current
    }, matchedProps);
  }, [styles, pseudoSelectors]);
}
/**
 * Takes a styleConfig object and outputs a `className` and `boxProps` that can be spread on a Box component
 * @param {string} componentKey the name of the component in the theme
 * @param {StyleModifiers} props props that modify the resulting visual style (e.g. `size` or `appearance`)
 * @param {PseudoSelectors} pseudoSelectors mapping for the component between states and actual pseudo selectors
 * @param {GlamorAndBoxStyle} [internalStyles] additional styles that are specified internally, separate from the visual styles
 * @returns {{ className: string; boxProps: import('ui-box').EnhancerProps }}
 */


function useStyleConfig(componentKey, props, pseudoSelectors, internalStyles) {
  var theme = (0, _theme.useTheme)(); // Get the component style object from the theme

  var componentStyles = (0, _theme.get)(theme, "components.".concat(componentKey)) || {}; // Merges the theme styles with the modifiers/props (appearance, size, etc)

  var mergedStyles = useMergedStyles(theme, props, componentStyles, internalStyles); // Resolve theme token strings found throughout the style object

  var styles = (0, _react.useMemo)(function () {
    return (0, _theme.resolveThemeTokens)(theme, mergedStyles);
  }, [theme, mergedStyles]); // Finally, split up the styles based which ones Box supports and the rest construct a glamor className

  return useGlamorAndBox(styles, pseudoSelectors);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9ob29rcy91c2Utc3R5bGUtY29uZmlnLmpzIl0sIm5hbWVzIjpbIm1heWJlUnVuIiwidmFsdWUiLCJhcmdzIiwibWF5YmVSdW5EZWVwIiwicmF3IiwicmVzdWx0IiwiT2JqZWN0Iiwia2V5cyIsImtleSIsImNvbWJpbmVTdHlsZXMiLCJ0aGVtZSIsInByb3BzIiwic3R5bGVDb25maWciLCJpbnRlcm5hbFN0eWxlcyIsImNvbmZpZyIsImJhc2VTdHlsZSIsInNpemVTdHlsZSIsInNpemUiLCJhcHBlYXJhbmNlU3R5bGUiLCJhcHBlYXJhbmNlIiwidXNlTWVyZ2VkU3R5bGVzIiwic3R5bGVSZWYiLCJjb21iaW5lZFN0eWxlcyIsImN1cnJlbnQiLCJ1c2VHbGFtb3JBbmRCb3giLCJzdHlsZXMiLCJwc2V1ZG9TZWxlY3RvcnMiLCJnbGFtb3JTdHlsZXNSZWYiLCJjbGFzc05hbWVSZWYiLCJtYXRjaGVkUHJvcHMiLCJyZW1haW5pbmdQcm9wcyIsImdsYW1vclN0eWxlcyIsImsiLCJjbGFzc05hbWUiLCJ0b1N0cmluZyIsInVuZGVmaW5lZCIsInVzZVN0eWxlQ29uZmlnIiwiY29tcG9uZW50S2V5IiwiY29tcG9uZW50U3R5bGVzIiwibWVyZ2VkU3R5bGVzIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUEsU0FBU0EsUUFBVCxDQUFrQkMsS0FBbEIsRUFBa0M7QUFBQSxvQ0FBTkMsSUFBTTtBQUFOQSxJQUFBQSxJQUFNO0FBQUE7O0FBQ2hDLFNBQU8sT0FBT0QsS0FBUCxLQUFpQixVQUFqQixHQUE4QkEsS0FBSyxNQUFMLFNBQVNDLElBQVQsQ0FB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U25GOztBQUNBLE1BQU1ZLE1BQU0sR0FBRyxvQkFBUTtBQUFBLFdBQU0sK0JBQW1CZixLQUFuQixFQUEwQjZCLFlBQTFCLENBQU47QUFBQSxHQUFSLEVBQXVELENBQUM3QixLQUFELEVBQVE2QixZQUFSLENBQXZELENBQWYsQ0FWbUYsQ0FZbkY7O0FBQ0EsU0FBT2YsZUFBZSxDQUFDQyxNQUFELEVBQVNDLGVBQVQsQ0FBdEI7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgY3NzIH0gZnJvbSAnZ2xhbW9yJ1xuaW1wb3J0IG1lcmdlIGZyb20gJ2xvZGFzaC5tZXJnZSdcbmltcG9ydCBpc0VxdWFsIGZyb20gJ3JlYWN0LWZhc3QtY29tcGFyZSdcbmltcG9ydCB7IHNwbGl0Qm94UHJvcHMgfSBmcm9tICd1aS1ib3gnXG5pbXBvcnQgeyB1c2VUaGVtZSwgZ2V0LCByZXNvbHZlVGhlbWVUb2tlbnMgfSBmcm9tICcuLi90aGVtZSdcblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBTdGF0ZVN0eWxlc1xuICogQHByb3BlcnR5IHtpbXBvcnQoJ2Nzc3R5cGUnKS5Qcm9wZXJ0aWVzfSBbX2hvdmVyXVxuICogQHByb3BlcnR5IHtpbXBvcnQoJ2Nzc3R5cGUnKS5Qcm9wZXJ0aWVzfSBbX2FjdGl2ZV1cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdjc3N0eXBlJykuUHJvcGVydGllc30gW19kaXNhYmxlZF1cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdjc3N0eXBlJykuUHJvcGVydGllc30gW19mb2N1c11cbiAqIEBwcm9wZXJ0eSB7aW1wb3J0KCdjc3N0eXBlJykuUHJvcGVydGllc30gW19pbnZhbGlkXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3sgW3BsYWNlaG9sZGVyIGluIGtleW9mIFN0YXRlU3R5bGVzXTogc3RyaW5nIH19IFBzZXVkb1NlbGVjdG9yc1xuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gU3R5bGVNb2RpZmllcnNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbYXBwZWFyYW5jZV1cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbc2l6ZV1cbiAqL1xuXG4vKiogQHR5cGVkZWYge2ltcG9ydCgndWktYm94JykuRW5oYW5jZXJQcm9wcyAmIFN0YXRlU3R5bGVzfSBTdHlsZSAqL1xuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ3VpLWJveCcpLkVuaGFuY2VyUHJvcHMgJiBpbXBvcnQoJ2dsYW1vcicpLkNTU1Byb3BlcnRpZXN9IEdsYW1vckFuZEJveFN0eWxlICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gU3R5bGVDb25maWdcbiAqIEBwcm9wZXJ0eSB7U3R5bGV9IGJhc2VTdHlsZVxuICogQHByb3BlcnR5IHt7IFthcHBlYXJhbmNlOiBzdHJpbmddOiBTdHlsZSB9fSBbYXBwZWFyYW5jZXNdXG4gKiBAcHJvcGVydHkge3sgW3NpemU6IHN0cmluZ106IFN0eWxlIH19IFtzaXplc11cbiAqL1xuXG5mdW5jdGlvbiBtYXliZVJ1bih2YWx1ZSwgLi4uYXJncykge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUoLi4uYXJncykgOiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBtYXliZVJ1bkRlZXAocmF3LCAuLi5hcmdzKSB7XG4gIGlmIChyYXcgJiYgdHlwZW9mIHJhdyA9PT0gJ29iamVjdCcpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocmF3KSkge1xuICAgICAgcmVzdWx0W2tleV0gPSBtYXliZVJ1bkRlZXAocmF3W2tleV0sIC4uLmFyZ3MpXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcmV0dXJuIG1heWJlUnVuKHJhdywgLi4uYXJncylcbn1cblxuLyoqXG4gKiBDb21iaW5lcyBzdHlsZXMgZnJvbSBhIHN0eWxlQ29uZmlnLCB3aXRoIHRoZSBnaXZlbiBzdHlsZSBtb2RpZmllcnMgKGFwcGVhcmFuY2UsIHNpemUsIGV0YykgYW5kIGludGVybmFsIHN0eWxlc1xuICogQHBhcmFtIHtvYmplY3R9IHRoZW1lXG4gKiBAcGFyYW0ge1N0eWxlTW9kaWZpZXJzfSBwcm9wc1xuICogQHBhcmFtIHtTdHlsZUNvbmZpZ30gc3R5bGVDb25maWdcbiAqIEBwYXJhbSB7R2xhbW9yQW5kQm94U3R5bGV9IFtpbnRlcm5hbFN0eWxlc11cbiAqIEByZXR1cm5zIHtTdHlsZUNvbmZpZ31cbiAqL1xuZnVuY3Rpb24gY29tYmluZVN0eWxlcyh0aGVtZSwgcHJvcHMsIHN0eWxlQ29uZmlnLCBpbnRlcm5hbFN0eWxlcyA9IHt9KSB7XG4gIGNvbnN0IGNvbmZpZyA9IG1heWJlUnVuKHN0eWxlQ29uZmlnLCB0aGVtZSwgcHJvcHMpXG4gIGNvbnN0IGJhc2VTdHlsZSA9IG1heWJlUnVuRGVlcChjb25maWcuYmFzZVN0eWxlLCB0aGVtZSwgcHJvcHMpXG4gIGNvbnN0IHNpemVTdHlsZSA9IG1heWJlUnVuRGVlcChnZXQoY29uZmlnLCBgc2l6ZXMuJHtwcm9wcy5zaXplfWAsIHt9KSwgdGhlbWUsIHByb3BzKVxuXG4gIGNvbnN0IGFwcGVhcmFuY2VTdHlsZSA9IG1heWJlUnVuRGVlcChnZXQoY29uZmlnLCBgYXBwZWFyYW5jZXMuJHtwcm9wcy5hcHBlYXJhbmNlfWAsIHt9KSwgdGhlbWUsIHByb3BzKVxuXG4gIHJldHVybiBtZXJnZSh7fSwgaW50ZXJuYWxTdHlsZXMsIGJhc2VTdHlsZSwgc2l6ZVN0eWxlLCBhcHBlYXJhbmNlU3R5bGUpXG59XG5cbi8qKlxuICogQ29tYmluZXMgYSBzdHlsZUNvbmZpZyBvYmplY3Qgd2l0aCBpbnRlcm5hbCBzdHlsZXMgYmFzZWQgb24gdGhlIHRoZW1lICsgc3R5bGUgbW9kaWZpZXJzIChwcm9wcylcbiAqIGFuZCByZXR1cm5zIGEgbWVtb2l6ZWQgc3R5bGUgb2JqZWN0XG4gKiBAcmV0dXJucyB7U3R5bGVDb25maWd9XG4gKi9cbmZ1bmN0aW9uIHVzZU1lcmdlZFN0eWxlcyh0aGVtZSwgcHJvcHMsIHN0eWxlQ29uZmlnLCBpbnRlcm5hbFN0eWxlcykge1xuICBjb25zdCBzdHlsZVJlZiA9IHVzZVJlZih7fSlcblxuICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgY29tYmluZWRTdHlsZXMgPSBjb21iaW5lU3R5bGVzKHRoZW1lLCBwcm9wcywgc3R5bGVDb25maWcsIGludGVybmFsU3R5bGVzKVxuICAgIGlmICghaXNFcXVhbChzdHlsZVJlZi5jdXJyZW50LCBjb21iaW5lZFN0eWxlcykpIHtcbiAgICAgIHN0eWxlUmVmLmN1cnJlbnQgPSBjb21iaW5lZFN0eWxlc1xuICAgIH1cblxuICAgIHJldHVybiBzdHlsZVJlZi5jdXJyZW50XG4gIH0sIFt0aGVtZSwgcHJvcHMsIHN0eWxlQ29uZmlnLCBpbnRlcm5hbFN0eWxlc10pXG59XG5cbi8qKlxuICogU3BsaXQgdXAgdGhlIHN0eWxlIHByb3BzIGludG8gZ2xhbW9yLXJlYWR5IGFuZCBib3gtcmVhZHkgcHJvcHMgKGNsYXNzTmFtZSArIHNwcmVhZGFibGUgcHJvcHMpXG4gKi9cbmZ1bmN0aW9uIHVzZUdsYW1vckFuZEJveChzdHlsZXMsIHBzZXVkb1NlbGVjdG9ycykge1xuICBjb25zdCBnbGFtb3JTdHlsZXNSZWYgPSB1c2VSZWYoe30pXG4gIGNvbnN0IGNsYXNzTmFtZVJlZiA9IHVzZVJlZigpXG5cbiAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgIC8vIFNwbGl0IHRoZSByZXN1bHRpbmcgc3R5bGUgb2JqZWN0IGludG8gdWktYm94LWNvbXBhdGlibGUgcHJvcHMgYW5kIHRoZSByZXN0XG4gICAgY29uc3QgeyBtYXRjaGVkUHJvcHMsIHJlbWFpbmluZ1Byb3BzIH0gPSBzcGxpdEJveFByb3BzKHN0eWxlcylcblxuICAgIC8qKiBAdHlwZSB7R2xhbW9yQW5kQm94U3R5bGV9ICovXG4gICAgY29uc3QgZ2xhbW9yU3R5bGVzID0ge31cblxuICAgIC8vIFN3YXAgb3V0IHBzZXVkbyBzZWxlY3RvciBwbGFjZWhvbGRlcnMgZm9yIHRoZWlyIGFjdHVhbCBjc3Mgc2VsZWN0b3Igc3RyaW5nc1xuICAgIGZvciAoY29uc3QgayBvZiBPYmplY3Qua2V5cyhyZW1haW5pbmdQcm9wcykpIHtcbiAgICAgIGNvbnN0IGtleSA9IGsgaW4gcHNldWRvU2VsZWN0b3JzID8gcHNldWRvU2VsZWN0b3JzW2tdIDoga1xuICAgICAgZ2xhbW9yU3R5bGVzW2tleV0gPSByZW1haW5pbmdQcm9wc1trXVxuICAgIH1cblxuICAgIC8vIFRha2UgYWxsIHRoZSBcIm5vbi1jb21wYXRpYmxlXCIgcHJvcHMgYW5kIGdpdmUgdGhvc2UgdG8gZ2xhbW9yIChzaW5jZSB1aS1ib3ggZG9lc24ndCBrbm93IGhvdyB0byBoYW5kbGUgdGhlbSB5ZXQpXG4gICAgaWYgKCFpc0VxdWFsKGdsYW1vclN0eWxlc1JlZi5jdXJyZW50LCBnbGFtb3JTdHlsZXMpKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBjc3MoZ2xhbW9yU3R5bGVzKS50b1N0cmluZygpXG4gICAgICBnbGFtb3JTdHlsZXNSZWYuY3VycmVudCA9IGdsYW1vclN0eWxlc1xuICAgICAgY2xhc3NOYW1lUmVmLmN1cnJlbnQgPSBjbGFzc05hbWUgPT09ICdjc3MtbmlsJyA/IHVuZGVmaW5lZCA6IGNsYXNzTmFtZVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjbGFzc05hbWU6IGNsYXNzTmFtZVJlZi5jdXJyZW50LFxuICAgICAgLi4ubWF0Y2hlZFByb3BzXG4gICAgfVxuICB9LCBbc3R5bGVzLCBwc2V1ZG9TZWxlY3RvcnNdKVxufVxuXG4vKipcbiAqIFRha2VzIGEgc3R5bGVDb25maWcgb2JqZWN0IGFuZCBvdXRwdXRzIGEgYGNsYXNzTmFtZWAgYW5kIGBib3hQcm9wc2AgdGhhdCBjYW4gYmUgc3ByZWFkIG9uIGEgQm94IGNvbXBvbmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudEtleSB0aGUgbmFtZSBvZiB0aGUgY29tcG9uZW50IGluIHRoZSB0aGVtZVxuICogQHBhcmFtIHtTdHlsZU1vZGlmaWVyc30gcHJvcHMgcHJvcHMgdGhhdCBtb2RpZnkgdGhlIHJlc3VsdGluZyB2aXN1YWwgc3R5bGUgKGUuZy4gYHNpemVgIG9yIGBhcHBlYXJhbmNlYClcbiAqIEBwYXJhbSB7UHNldWRvU2VsZWN0b3JzfSBwc2V1ZG9TZWxlY3RvcnMgbWFwcGluZyBmb3IgdGhlIGNvbXBvbmVudCBiZXR3ZWVuIHN0YXRlcyBhbmQgYWN0dWFsIHBzZXVkbyBzZWxlY3RvcnNcbiAqIEBwYXJhbSB7R2xhbW9yQW5kQm94U3R5bGV9IFtpbnRlcm5hbFN0eWxlc10gYWRkaXRpb25hbCBzdHlsZXMgdGhhdCBhcmUgc3BlY2lmaWVkIGludGVybmFsbHksIHNlcGFyYXRlIGZyb20gdGhlIHZpc3VhbCBzdHlsZXNcbiAqIEByZXR1cm5zIHt7IGNsYXNzTmFtZTogc3RyaW5nOyBib3hQcm9wczogaW1wb3J0KCd1aS1ib3gnKS5FbmhhbmNlclByb3BzIH19XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VTdHlsZUNvbmZpZyhjb21wb25lbnRLZXksIHByb3BzLCBwc2V1ZG9TZWxlY3RvcnMsIGludGVybmFsU3R5bGVzKSB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKVxuXG4gIC8vIEdldCB0aGUgY29tcG9uZW50IHN0eWxlIG9iamVjdCBmcm9tIHRoZSB0aGVtZVxuICBjb25zdCBjb21wb25lbnRTdHlsZXMgPSBnZXQodGhlbWUsIGBjb21wb25lbnRzLiR7Y29tcG9uZW50S2V5fWApIHx8IHt9XG5cbiAgLy8gTWVyZ2VzIHRoZSB0aGVtZSBzdHlsZXMgd2l0aCB0aGUgbW9kaWZpZXJzL3Byb3BzIChhcHBlYXJhbmNlLCBzaXplLCBldGMpXG4gIGNvbnN0IG1lcmdlZFN0eWxlcyA9IHVzZU1lcmdlZFN0eWxlcyh0aGVtZSwgcHJvcHMsIGNvbXBvbmVudFN0eWxlcywgaW50ZXJuYWxTdHlsZXMpXG5cbiAgLy8gUmVzb2x2ZSB0aGVtZSB0b2tlbiBzdHJpbmdzIGZvdW5kIHRocm91Z2hvdXQgdGhlIHN0eWxlIG9iamVjdFxuICBjb25zdCBzdHlsZXMgPSB1c2VNZW1vKCgpID0+IHJlc29sdmVUaGVtZVRva2Vucyh0aGVtZSwgbWVyZ2VkU3R5bGVzKSwgW3RoZW1lLCBtZXJnZWRTdHlsZXNdKVxuXG4gIC8vIEZpbmFsbHksIHNwbGl0IHVwIHRoZSBzdHlsZXMgYmFzZWQgd2hpY2ggb25lcyBCb3ggc3VwcG9ydHMgYW5kIHRoZSByZXN0IGNvbnN0cnVjdCBhIGdsYW1vciBjbGFzc05hbWVcbiAgcmV0dXJuIHVzZUdsYW1vckFuZEJveChzdHlsZXMsIHBzZXVkb1NlbGVjdG9ycylcbn1cbiJdfQ==
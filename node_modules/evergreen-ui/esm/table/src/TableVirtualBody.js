import _extends from "@babel/runtime/helpers/esm/extends";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["allowAutoHeight", "children", "defaultHeight", "estimatedItemSize", "height", "onScroll", "overscanCount", "scrollOffset", "scrollToAlignment", "scrollToIndex", "useAverageAutoHeightEstimation"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { memo, useState, useEffect } from 'react';
import VirtualList from '@segment/react-tiny-virtual-list';
import debounce from 'lodash.debounce';
import PropTypes from 'prop-types';
import { useForceUpdate } from '../../hooks';
import { Pane } from '../../layers';
var TableVirtualBody = /*#__PURE__*/memo(function TableVirtualBody(props) {
  var _props$allowAutoHeigh = props.allowAutoHeight,
      allowAutoHeight = _props$allowAutoHeigh === void 0 ? false : _props$allowAutoHeigh,
      inputChildren = props.children,
      _props$defaultHeight = props.defaultHeight,
      defaultHeight = _props$defaultHeight === void 0 ? 48 : _props$defaultHeight,
      estimatedItemSize = props.estimatedItemSize,
      paneHeight = props.height,
      onScroll = props.onScroll,
      _props$overscanCount = props.overscanCount,
      overscanCount = _props$overscanCount === void 0 ? 5 : _props$overscanCount,
      scrollOffset = props.scrollOffset,
      scrollToAlignment = props.scrollToAlignment,
      scrollToIndex = props.scrollToIndex,
      _props$useAverageAuto = props.useAverageAutoHeightEstimation,
      useAverageAutoHeightEstimation = _props$useAverageAuto === void 0 ? true : _props$useAverageAuto,
      rest = _objectWithoutProperties(props, _excluded);

  var forceUpdate = useForceUpdate();
  var autoHeights = [];
  var autoHeightRefs = [];
  var averageAutoHeight = defaultHeight;

  var _useState = useState(),
      _useState2 = _slicedToArray(_useState, 2),
      paneRef = _useState2[0],
      setPaneRef = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isIntegerHeight = _useState4[0],
      setIsIntegerHeight = _useState4[1];

  var _useState5 = useState(0),
      _useState6 = _slicedToArray(_useState5, 2),
      calculatedHeight = _useState6[0],
      setCalculatedHeight = _useState6[1];

  var updateOnResize = function updateOnResize() {
    autoHeights = [];
    autoHeightRefs = [];
    averageAutoHeight = defaultHeight; // Simply return when we now the height of the pane is fixed.

    if (isIntegerHeight) return; // Return if we are in a weird edge case in which the ref is no longer valid.

    if (paneRef && paneRef instanceof Node) {
      var tempCalculatedHeight = paneRef.offsetHeight;

      if (tempCalculatedHeight > 0) {
        // Save the calculated height which is needed for the VirtualList.
        setCalculatedHeight(tempCalculatedHeight); // Prevent updateOnResize being called recursively when there is a valid height.

        return;
      }
    } // When height is still 0 (or paneRef is not valid) try recursively until success.


    requestAnimationFrame(function () {
      updateOnResize();
    });
  };

  var onResize = debounce(updateOnResize, 200);
  useEffect(function () {
    if (props.height !== calculatedHeight) {
      setIsIntegerHeight(Number.isInteger(props.height));
    }
  }, [props.height]);
  useEffect(function () {
    if (paneRef && paneRef instanceof Node) {
      updateOnResize();
    }
  }, [paneRef]); // Mirrors functionality of componentDidMount and componentWillUnmount.
  // By passing an empty array, will only run on first render, the function returned
  // will be called on component unmount

  useEffect(function () {
    updateOnResize();
    window.addEventListener('resize', onResize, false);
    return function () {
      window.removeEventListener('resize', onResize);
    };
  }, []);
  /**
   * This function will process all items that have height="auto" set.
   * It will loop through all refs and get calculate the height.
   */

  var processAutoHeights = function processAutoHeights() {
    var isUpdated = false; // This will determine the averageAutoHeight.

    var total = 0;
    var totalAmount = 0; // Loop through all of the refs that have height="auto".

    autoHeightRefs.forEach(function (ref, index) {
      // If the height is already calculated, skip it,
      // but calculate the height for the total.
      if (autoHeights[index]) {
        total += autoHeights[index];
        totalAmount += 1;
        return;
      } // Make sure the ref has a child


      if (ref && ref.childNodes && ref.childNodes[0] && Number.isInteger(ref.childNodes[0].offsetHeight)) {
        var height = ref.childNodes[0].offsetHeight; // Add to the total to calculate the averageAutoHeight.

        total += height;
        totalAmount += 1; // Cache the height.

        autoHeights[index] = height; // Set the update flag to true.

        isUpdated = true;
      }
    }); // Save the average height.

    averageAutoHeight = total / totalAmount; // There are some new heights detected that had previously not been calculated.
    // Call forceUpdate to make sure the virtual list renders again.

    if (isUpdated) forceUpdate();
  };

  var onVirtualHelperRef = function onVirtualHelperRef(index, ref) {
    autoHeightRefs[index] = ref;
    requestAnimationFrame(function () {
      processAutoHeights();
    });
  };

  var getItemSize = function getItemSize(children) {
    // Prefer to return a array of all heights.
    if (!allowAutoHeight) {
      return children.map(function (child) {
        if (! /*#__PURE__*/React.isValidElement(child)) return defaultHeight;
        var height = child.props.height;

        if (Number.isInteger(height)) {
          return height;
        }

        return defaultHeight;
      });
    } // If allowAutoHeight is true, return a function instead.


    var itemSizeFn = function itemSizeFn(index) {
      if (! /*#__PURE__*/React.isValidElement(children[index])) return defaultHeight;
      var height = children[index].props.height; // When the height is number simply, simply return it.

      if (Number.isInteger(height)) {
        return height;
      } // When allowAutoHeight is set and  the height is set to "auto"...


      if (allowAutoHeight && children[index].props.height === 'auto') {
        // ... and the height is calculated, return the calculated height.
        if (autoHeights[index]) return autoHeights[index]; // ... if the height is not yet calculated, return the averge

        if (useAverageAutoHeightEstimation) return averageAutoHeight;
      } // Return the default height.


      return defaultHeight;
    };

    return itemSizeFn;
  }; // Children always needs to be an array.


  var children = Array.isArray(inputChildren) ? inputChildren : React.Children.toArray(inputChildren);
  var itemSize = getItemSize(children);
  return /*#__PURE__*/React.createElement(Pane, _extends({
    "data-evergreen-table-body": true,
    ref: setPaneRef,
    height: paneHeight,
    flex: "1",
    overflow: "hidden"
  }, rest), /*#__PURE__*/React.createElement(VirtualList, {
    height: isIntegerHeight ? paneHeight : calculatedHeight,
    width: "100%",
    estimatedItemSize: allowAutoHeight && useAverageAutoHeightEstimation ? averageAutoHeight : estimatedItemSize || null,
    itemSize: itemSize,
    overscanCount: overscanCount,
    itemCount: React.Children.count(children),
    scrollToIndex: scrollToIndex,
    scrollOffset: scrollOffset,
    scrollToAlignment: scrollToAlignment,
    onScroll: onScroll,
    renderItem: function renderItem(_ref) {
      var index = _ref.index,
          style = _ref.style;
      var child = children[index];
      var key = child.key || index;
      var props = {
        key: key,
        style: style
      }; // If some children are strings by accident, support this gracefully.

      if (! /*#__PURE__*/React.isValidElement(child)) {
        if (typeof child === 'string') {
          return /*#__PURE__*/React.createElement("div", props, child);
        }

        return /*#__PURE__*/React.createElement("div", props, "\xA0");
      } // When allowing height="auto" for rows, and a auto height item is
      // rendered for the first time...


      if (allowAutoHeight && /*#__PURE__*/React.isValidElement(child) && child.props.height === 'auto' && // ... and only when the height is not already been calculated.
      !autoHeights[index]) {
        // ... render the item in a helper div, the ref is used to calculate
        // the height of its children.
        return /*#__PURE__*/React.createElement("div", _extends({
          ref: function ref(_ref2) {
            return onVirtualHelperRef(index, _ref2);
          },
          "data-virtual-index": index
        }, props, {
          style: _objectSpread({
            opacity: 0
          }, props.style)
        }), child);
      } // When allowAutoHeight is false, or when the height is known.
      // Simply render the item.


      return /*#__PURE__*/React.cloneElement(child, props);
    }
  }));
});
TableVirtualBody.propTypes = _objectSpread(_objectSpread({}, Pane.propTypes), {}, {
  /**
   * Children needs to be an array of a single node.
   */
  children: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.node), PropTypes.node]),

  /**
   * Default height of each row.
   * 48 is the default height of a TableRow.
   */
  defaultHeight: PropTypes.number,

  /**
   * When true, support `height="auto"` on children being rendered.
   * This is somewhat of an expirmental feature.
   */
  allowAutoHeight: PropTypes.bool,

  /**
   * The overscanCount property passed to react-tiny-virtual-list.
   */
  overscanCount: PropTypes.number,

  /**
   * When passed, this is used as the `estimatedItemSize` in react-tiny-virtual-list.
   * Only when `allowAutoHeight` and`useAverageAutoHeightEstimation` are false.
   */
  estimatedItemSize: PropTypes.number,

  /**
   * When allowAutoHeight is true and this prop is true, the estimated height
   * will be computed based on the average height of auto height rows.
   */
  useAverageAutoHeightEstimation: PropTypes.bool,

  /**
   * The scrollToIndex property passed to react-tiny-virtual-list
   */
  scrollToIndex: PropTypes.number,

  /**
   * The scrollOffset property passed to react-tiny-virtual-list
   */
  scrollOffset: PropTypes.number,

  /**
   * The scrollToAlignment property passed to react-tiny-virtual-list
   */
  scrollToAlignment: PropTypes.oneOf(['start', 'center', 'end', 'auto']),

  /**
   * The onScroll callback passed to react-tiny-virtual-list
   */
  onScroll: PropTypes.func
});
export default TableVirtualBody;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvVGFibGVWaXJ0dWFsQm9keS5qcyJdLCJuYW1lcyI6WyJSZWFjdCIsIm1lbW8iLCJ1c2VTdGF0ZSIsInVzZUVmZmVjdCIsIlZpcnR1YWxMaXN0IiwiZGVib3VuY2UiLCJQcm9wVHlwZXMiLCJ1c2VGb3JjZVVwZGF0ZSIsIlBhbmUiLCJUYWJsZVZpcnR1YWxCb2R5IiwicHJvcHMiLCJhbGxvd0F1dG9IZWlnaHQiLCJpbnB1dENoaWxkcmVuIiwiY2hpbGRyZW4iLCJkZWZhdWx0SGVpZ2h0IiwiZXN0aW1hdGVkSXRlbVNpemUiLCJwYW5lSGVpZ2h0IiwiaGVpZ2h0Iiwib25TY3JvbGwiLCJvdmVyc2NhbkNvdW50Iiwic2Nyb2xsT2Zmc2V0Iiwic2Nyb2xsVG9BbGlnbm1lbnQiLCJzY3JvbGxUb0luZGV4IiwidXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uIiwicmVzdCIsImZvcmNlVXBkYXRlIiwiYXV0b0hlaWdodHMiLCJhdXRvSGVpZ2h0UmVmcyIsImF2ZXJhZ2VBdXRvSGVpZ2h0IiwicGFuZVJlZiIsInNldFBhbmVSZWYiLCJpc0ludGVnZXJIZWlnaHQiLCJzZXRJc0ludGVnZXJIZWlnaHQiLCJjYWxjdWxhdGVkSGVpZ2h0Iiwic2V0Q2FsY3VsYXRlZEhlaWdodCIsInVwZGF0ZU9uUmVzaXplIiwiTm9kZSIsInRlbXBDYWxjdWxhdGVkSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwib25SZXNpemUiLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInByb2Nlc3NBdXRvSGVpZ2h0cyIsImlzVXBkYXRlZCIsInRvdGFsIiwidG90YWxBbW91bnQiLCJmb3JFYWNoIiwicmVmIiwiaW5kZXgiLCJjaGlsZE5vZGVzIiwib25WaXJ0dWFsSGVscGVyUmVmIiwiZ2V0SXRlbVNpemUiLCJtYXAiLCJjaGlsZCIsImlzVmFsaWRFbGVtZW50IiwiaXRlbVNpemVGbiIsIkFycmF5IiwiaXNBcnJheSIsIkNoaWxkcmVuIiwidG9BcnJheSIsIml0ZW1TaXplIiwiY291bnQiLCJzdHlsZSIsImtleSIsIm9wYWNpdHkiLCJjbG9uZUVsZW1lbnQiLCJwcm9wVHlwZXMiLCJvbmVPZlR5cGUiLCJhcnJheU9mIiwibm9kZSIsIm51bWJlciIsImJvb2wiLCJvbmVPZiIsImZ1bmMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxJQUFoQixFQUFzQkMsUUFBdEIsRUFBZ0NDLFNBQWhDLFFBQWlELE9BQWpEO0FBQ0EsT0FBT0MsV0FBUCxNQUF3QixrQ0FBeEI7QUFDQSxPQUFPQyxRQUFQLE1BQXFCLGlCQUFyQjtBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxTQUFTQyxjQUFULFFBQStCLGFBQS9CO0FBQ0EsU0FBU0MsSUFBVCxRQUFxQixjQUFyQjtBQUVBLElBQU1DLGdCQUFnQixnQkFBR1IsSUFBSSxDQUFDLFNBQVNRLGdCQUFULENBQTBCQyxLQUExQixFQUFpQztBQUM3RCw4QkFhSUEsS0FiSixDQUNFQyxlQURGO0FBQUEsTUFDRUEsZUFERixzQ0FDb0IsS0FEcEI7QUFBQSxNQUVZQyxhQUZaLEdBYUlGLEtBYkosQ0FFRUcsUUFGRjtBQUFBLDZCQWFJSCxLQWJKLENBR0VJLGFBSEY7QUFBQSxNQUdFQSxhQUhGLHFDQUdrQixFQUhsQjtBQUFBLE1BSUVDLGlCQUpGLEdBYUlMLEtBYkosQ0FJRUssaUJBSkY7QUFBQSxNQUtVQyxVQUxWLEdBYUlOLEtBYkosQ0FLRU8sTUFMRjtBQUFBLE1BTUVDLFFBTkYsR0FhSVIsS0FiSixDQU1FUSxRQU5GO0FBQUEsNkJBYUlSLEtBYkosQ0FPRVMsYUFQRjtBQUFBLE1BT0VBLGFBUEYscUNBT2tCLENBUGxCO0FBQUEsTUFRRUMsWUFSRixHQWFJVixLQWJKLENBUUVVLFlBUkY7QUFBQSxNQVNFQyxpQkFURixHQWFJWCxLQWJKLENBU0VXLGlC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IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFZpcnR1YWxMaXN0IGZyb20gJ0BzZWdtZW50L3JlYWN0LXRpbnktdmlydHVhbC1saXN0J1xuaW1wb3J0IGRlYm91bmNlIGZyb20gJ2xvZGFzaC5kZWJvdW5jZSdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCB7IHVzZUZvcmNlVXBkYXRlIH0gZnJvbSAnLi4vLi4vaG9va3MnXG5pbXBvcnQgeyBQYW5lIH0gZnJvbSAnLi4vLi4vbGF5ZXJzJ1xuXG5jb25zdCBUYWJsZVZpcnR1YWxCb2R5ID0gbWVtbyhmdW5jdGlvbiBUYWJsZVZpcnR1YWxCb2R5KHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBhbGxvd0F1dG9IZWlnaHQgPSBmYWxzZSxcbiAgICBjaGlsZHJlbjogaW5wdXRDaGlsZHJlbixcbiAgICBkZWZhdWx0SGVpZ2h0ID0gNDgsXG4gICAgZXN0aW1hdGVkSXRlbVNpemUsXG4gICAgaGVpZ2h0OiBwYW5lSGVpZ2h0LFxuICAgIG9uU2Nyb2xsLFxuICAgIG92ZXJzY2FuQ291bnQgPSA1LFxuICAgIHNjcm9sbE9mZnNldCxcbiAgICBzY3JvbGxUb0FsaWdubWVudCxcbiAgICBzY3JvbGxUb0luZGV4LFxuICAgIHVzZUF2ZXJhZ2VBdXRvSGVpZ2h0RXN0aW1hdGlvbiA9IHRydWUsXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBmb3JjZVVwZGF0ZSA9IHVzZUZvcmNlVXBkYXRlKClcbiAgbGV0IGF1dG9IZWlnaHRzID0gW11cbiAgbGV0IGF1dG9IZWlnaHRSZWZzID0gW11cbiAgbGV0IGF2ZXJhZ2VBdXRvSGVpZ2h0ID0gZGVmYXVsdEhlaWdodFxuXG4gIGNvbnN0IFtwYW5lUmVmLCBzZXRQYW5lUmVmXSA9IHVzZVN0YXRlKClcbiAgY29uc3QgW2lzSW50ZWdlckhlaWdodCwgc2V0SXNJbnRlZ2VySGVpZ2h0XSA9IHVzZVN0YXRlKGZhbHNlKVxuICBjb25zdCBbY2FsY3VsYXRlZEhlaWdodCwgc2V0Q2FsY3VsYXRlZEhlaWdodF0gPSB1c2VTdGF0ZSgwKVxuXG4gIGNvbnN0IHVwZGF0ZU9uUmVzaXplID0gKCkgPT4ge1xuICAgIGF1dG9IZWlnaHRzID0gW11cbiAgICBhdXRvSGVpZ2h0UmVmcyA9IFtdXG4gICAgYXZlcmFnZUF1dG9IZWlnaHQgPSBkZWZhdWx0SGVpZ2h0XG5cbiAgICAvLyBTaW1wbHkgcmV0dXJuIHdoZW4gd2Ugbm93IHRoZSBoZWlnaHQgb2YgdGhlIHBhbmUgaXMgZml4ZWQuXG4gICAgaWYgKGlzSW50ZWdlckhlaWdodCkgcmV0dXJuXG5cbiAgICAvLyBSZXR1cm4gaWYgd2UgYXJlIGluIGEgd2VpcmQgZWRnZSBjYXNlIGluIHdoaWNoIHRoZSByZWYgaXMgbm8gbG9uZ2VyIHZhbGlkLlxuICAgIGlmIChwYW5lUmVmICYmIHBhbmVSZWYgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICBjb25zdCB0ZW1wQ2FsY3VsYXRlZEhlaWdodCA9IHBhbmVSZWYub2Zmc2V0SGVpZ2h0XG5cbiAgICAgIGlmICh0ZW1wQ2FsY3VsYXRlZEhlaWdodCA+IDApIHtcbiAgICAgICAgLy8gU2F2ZSB0aGUgY2FsY3VsYXRlZCBoZWlnaHQgd2hpY2ggaXMgbmVlZGVkIGZvciB0aGUgVmlydHVhbExpc3QuXG4gICAgICAgIHNldENhbGN1bGF0ZWRIZWlnaHQodGVtcENhbGN1bGF0ZWRIZWlnaHQpXG5cbiAgICAgICAgLy8gUHJldmVudCB1cGRhdGVPblJlc2l6ZSBiZWluZyBjYWxsZWQgcmVjdXJzaXZlbHkgd2hlbiB0aGVyZSBpcyBhIHZhbGlkIGhlaWdodC5cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2hlbiBoZWlnaHQgaXMgc3RpbGwgMCAob3IgcGFuZVJlZiBpcyBub3QgdmFsaWQpIHRyeSByZWN1cnNpdmVseSB1bnRpbCBzdWNjZXNzLlxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB1cGRhdGVPblJlc2l6ZSgpXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IG9uUmVzaXplID0gZGVib3VuY2UodXBkYXRlT25SZXNpemUsIDIwMClcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwcm9wcy5oZWlnaHQgIT09IGNhbGN1bGF0ZWRIZWlnaHQpIHtcbiAgICAgIHNldElzSW50ZWdlckhlaWdodChOdW1iZXIuaXNJbnRlZ2VyKHByb3BzLmhlaWdodCkpXG4gICAgfVxuICB9LCBbcHJvcHMuaGVpZ2h0XSlcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChwYW5lUmVmICYmIHBhbmVSZWYgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICB1cGRhdGVPblJlc2l6ZSgpXG4gICAgfVxuICB9LCBbcGFuZVJlZl0pXG5cbiAgLy8gTWlycm9ycyBmdW5jdGlvbmFsaXR5IG9mIGNvbXBvbmVudERpZE1vdW50IGFuZCBjb21wb25lbnRXaWxsVW5tb3VudC5cbiAgLy8gQnkgcGFzc2luZyBhbiBlbXB0eSBhcnJheSwgd2lsbCBvbmx5IHJ1biBvbiBmaXJzdCByZW5kZXIsIHRoZSBmdW5jdGlvbiByZXR1cm5lZFxuICAvLyB3aWxsIGJlIGNhbGxlZCBvbiBjb21wb25lbnQgdW5tb3VudFxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHVwZGF0ZU9uUmVzaXplKClcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgb25SZXNpemUsIGZhbHNlKVxuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBvblJlc2l6ZSlcbiAgICB9XG4gIH0sIFtdKVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgcHJvY2VzcyBhbGwgaXRlbXMgdGhhdCBoYXZlIGhlaWdodD1cImF1dG9cIiBzZXQuXG4gICAqIEl0IHdpbGwgbG9vcCB0aHJvdWdoIGFsbCByZWZzIGFuZCBnZXQgY2FsY3VsYXRlIHRoZSBoZWlnaHQuXG4gICAqL1xuICBjb25zdCBwcm9jZXNzQXV0b0hlaWdodHMgPSAoKSA9PiB7XG4gICAgbGV0IGlzVXBkYXRlZCA9IGZhbHNlXG5cbiAgICAvLyBUaGlzIHdpbGwgZGV0ZXJtaW5lIHRoZSBhdmVyYWdlQXV0b0hlaWdodC5cbiAgICBsZXQgdG90YWwgPSAwXG4gICAgbGV0IHRvdGFsQW1vdW50ID0gMFxuXG4gICAgLy8gTG9vcCB0aHJvdWdoIGFsbCBvZiB0aGUgcmVmcyB0aGF0IGhhdmUgaGVpZ2h0PVwiYXV0b1wiLlxuICAgIGF1dG9IZWlnaHRSZWZzLmZvckVhY2goKHJlZiwgaW5kZXgpID0+IHtcbiAgICAgIC8vIElmIHRoZSBoZWlnaHQgaXMgYWxyZWFkeSBjYWxjdWxhdGVkLCBza2lwIGl0LFxuICAgICAgLy8gYnV0IGNhbGN1bGF0ZSB0aGUgaGVpZ2h0IGZvciB0aGUgdG90YWwuXG4gICAgICBpZiAoYXV0b0hlaWdodHNbaW5kZXhdKSB7XG4gICAgICAgIHRvdGFsICs9IGF1dG9IZWlnaHRzW2luZGV4XVxuICAgICAgICB0b3RhbEFtb3VudCArPSAxXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBNYWtlIHN1cmUgdGhlIHJlZiBoYXMgYSBjaGlsZFxuICAgICAgaWYgKHJlZiAmJiByZWYuY2hpbGROb2RlcyAmJiByZWYuY2hpbGROb2Rlc1swXSAmJiBOdW1iZXIuaXNJbnRlZ2VyKHJlZi5jaGlsZE5vZGVzWzBdLm9mZnNldEhlaWdodCkpIHtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcmVmLmNoaWxkTm9kZXNbMF0ub2Zmc2V0SGVpZ2h0XG5cbiAgICAgICAgLy8gQWRkIHRvIHRoZSB0b3RhbCB0byBjYWxjdWxhdGUgdGhlIGF2ZXJhZ2VBdXRvSGVpZ2h0LlxuICAgICAgICB0b3RhbCArPSBoZWlnaHRcbiAgICAgICAgdG90YWxBbW91bnQgKz0gMVxuXG4gICAgICAgIC8vIENhY2hlIHRoZSBoZWlnaHQuXG4gICAgICAgIGF1dG9IZWlnaHRzW2luZGV4XSA9IGhlaWdodFxuXG4gICAgICAgIC8vIFNldCB0aGUgdXBkYXRlIGZsYWcgdG8gdHJ1ZS5cbiAgICAgICAgaXNVcGRhdGVkID0gdHJ1ZVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBTYXZlIHRoZSBhdmVyYWdlIGhlaWdodC5cbiAgICBhdmVyYWdlQXV0b0hlaWdodCA9IHRvdGFsIC8gdG90YWxBbW91bnRcblxuICAgIC8vIFRoZXJlIGFyZSBzb21lIG5ldyBoZWlnaHRzIGRldGVjdGVkIHRoYXQgaGFkIHByZXZpb3VzbHkgbm90IGJlZW4gY2FsY3VsYXRlZC5cbiAgICAvLyBDYWxsIGZvcmNlVXBkYXRlIHRvIG1ha2Ugc3VyZSB0aGUgdmlydHVhbCBsaXN0IHJlbmRlcnMgYWdhaW4uXG4gICAgaWYgKGlzVXBkYXRlZCkgZm9yY2VVcGRhdGUoKVxuICB9XG5cbiAgY29uc3Qgb25WaXJ0dWFsSGVscGVyUmVmID0gKGluZGV4LCByZWYpID0+IHtcbiAgICBhdXRvSGVpZ2h0UmVmc1tpbmRleF0gPSByZWZcblxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICBwcm9jZXNzQXV0b0hlaWdodHMoKVxuICAgIH0pXG4gIH1cblxuICBjb25zdCBnZXRJdGVtU2l6ZSA9IGNoaWxkcmVuID0+IHtcbiAgICAvLyBQcmVmZXIgdG8gcmV0dXJuIGEgYXJyYXkgb2YgYWxsIGhlaWdodHMuXG4gICAgaWYgKCFhbGxvd0F1dG9IZWlnaHQpIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5tYXAoY2hpbGQgPT4ge1xuICAgICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSkgcmV0dXJuIGRlZmF1bHRIZWlnaHRcbiAgICAgICAgY29uc3QgeyBoZWlnaHQgfSA9IGNoaWxkLnByb3BzXG5cbiAgICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaGVpZ2h0KSkge1xuICAgICAgICAgIHJldHVybiBoZWlnaHRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0SGVpZ2h0XG4gICAgICB9KVxuICAgIH1cblxuICAgIC8vIElmIGFsbG93QXV0b0hlaWdodCBpcyB0cnVlLCByZXR1cm4gYSBmdW5jdGlvbiBpbnN0ZWFkLlxuICAgIGNvbnN0IGl0ZW1TaXplRm4gPSBpbmRleCA9PiB7XG4gICAgICBpZiAoIVJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuW2luZGV4XSkpIHJldHVybiBkZWZhdWx0SGVpZ2h0XG4gICAgICBjb25zdCB7IGhlaWdodCB9ID0gY2hpbGRyZW5baW5kZXhdLnByb3BzXG5cbiAgICAgIC8vIFdoZW4gdGhlIGhlaWdodCBpcyBudW1iZXIgc2ltcGx5LCBzaW1wbHkgcmV0dXJuIGl0LlxuICAgICAgaWYgKE51bWJlci5pc0ludGVnZXIoaGVpZ2h0KSkge1xuICAgICAgICByZXR1cm4gaGVpZ2h0XG4gICAgICB9XG5cbiAgICAgIC8vIFdoZW4gYWxsb3dBdXRvSGVpZ2h0IGlzIHNldCBhbmQgIHRoZSBoZWlnaHQgaXMgc2V0IHRvIFwiYXV0b1wiLi4uXG4gICAgICBpZiAoYWxsb3dBdXRvSGVpZ2h0ICYmIGNoaWxkcmVuW2luZGV4XS5wcm9wcy5oZWlnaHQgPT09ICdhdXRvJykge1xuICAgICAgICAvLyAuLi4gYW5kIHRoZSBoZWlnaHQgaXMgY2FsY3VsYXRlZCwgcmV0dXJuIHRoZSBjYWxjdWxhdGVkIGhlaWdodC5cbiAgICAgICAgaWYgKGF1dG9IZWlnaHRzW2luZGV4XSkgcmV0dXJuIGF1dG9IZWlnaHRzW2luZGV4XVxuXG4gICAgICAgIC8vIC4uLiBpZiB0aGUgaGVpZ2h0IGlzIG5vdCB5ZXQgY2FsY3VsYXRlZCwgcmV0dXJuIHRoZSBhdmVyZ2VcbiAgICAgICAgaWYgKHVzZUF2ZXJhZ2VBdXRvSGVpZ2h0RXN0aW1hdGlvbikgcmV0dXJuIGF2ZXJhZ2VBdXRvSGVpZ2h0XG4gICAgICB9XG5cbiAgICAgIC8vIFJldHVybiB0aGUgZGVmYXVsdCBoZWlnaHQuXG4gICAgICByZXR1cm4gZGVmYXVsdEhlaWdodFxuICAgIH1cblxuICAgIHJldHVybiBpdGVtU2l6ZUZuXG4gIH1cblxuICAvLyBDaGlsZHJlbiBhbHdheXMgbmVlZHMgdG8gYmUgYW4gYXJyYXkuXG4gIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuaXNBcnJheShpbnB1dENoaWxkcmVuKSA/IGlucHV0Q2hpbGRyZW4gOiBSZWFjdC5DaGlsZHJlbi50b0FycmF5KGlucHV0Q2hpbGRyZW4pXG5cbiAgY29uc3QgaXRlbVNpemUgPSBnZXRJdGVtU2l6ZShjaGlsZHJlbilcblxuICByZXR1cm4gKFxuICAgIDxQYW5lIGRhdGEtZXZlcmdyZWVuLXRhYmxlLWJvZHkgcmVmPXtzZXRQYW5lUmVmfSBoZWlnaHQ9e3BhbmVIZWlnaHR9IGZsZXg9XCIxXCIgb3ZlcmZsb3c9XCJoaWRkZW5cIiB7Li4ucmVzdH0+XG4gICAgICA8VmlydHVhbExpc3RcbiAgICAgICAgaGVpZ2h0PXtpc0ludGVnZXJIZWlnaHQgPyBwYW5lSGVpZ2h0IDogY2FsY3VsYXRlZEhlaWdodH1cbiAgICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgICAgZXN0aW1hdGVkSXRlbVNpemU9e1xuICAgICAgICAgIGFsbG93QXV0b0hlaWdodCAmJiB1c2VBdmVyYWdlQXV0b0hlaWdodEVzdGltYXRpb24gPyBhdmVyYWdlQXV0b0hlaWdodCA6IGVzdGltYXRlZEl0ZW1TaXplIHx8IG51bGxcbiAgICAgICAgfVxuICAgICAgICBpdGVtU2l6ZT17aXRlbVNpemV9XG4gICAgICAgIG92ZXJzY2FuQ291bnQ9e292ZXJzY2FuQ291bnR9XG4gICAgICAgIGl0ZW1Db3VudD17UmVhY3QuQ2hpbGRyZW4uY291bnQoY2hpbGRyZW4pfVxuICAgICAgICBzY3JvbGxUb0luZGV4PXtzY3JvbGxUb0luZGV4fVxuICAgICAgICBzY3JvbGxPZmZzZXQ9e3Njcm9sbE9mZnNldH1cbiAgICAgICAgc2Nyb2xsVG9BbGlnbm1lbnQ9e3Njcm9sbFRvQWxpZ25tZW50fVxuICAgICAgICBvblNjcm9sbD17b25TY3JvbGx9XG4gICAgICAgIHJlbmRlckl0ZW09eyh7IGluZGV4LCBzdHlsZSB9KSA9PiB7XG4gICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltpbmRleF1cbiAgICAgICAgICBjb25zdCBrZXkgPSBjaGlsZC5rZXkgfHwgaW5kZXhcbiAgICAgICAgICBjb25zdCBwcm9wcyA9IHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIHN0eWxlXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgc29tZSBjaGlsZHJlbiBhcmUgc3RyaW5ncyBieSBhY2NpZGVudCwgc3VwcG9ydCB0aGlzIGdyYWNlZnVsbHkuXG4gICAgICAgICAgaWYgKCFSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIHJldHVybiA8ZGl2IHsuLi5wcm9wc30+e2NoaWxkfTwvZGl2PlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gPGRpdiB7Li4ucHJvcHN9PiZuYnNwOzwvZGl2PlxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gYWxsb3dpbmcgaGVpZ2h0PVwiYXV0b1wiIGZvciByb3dzLCBhbmQgYSBhdXRvIGhlaWdodCBpdGVtIGlzXG4gICAgICAgICAgLy8gcmVuZGVyZWQgZm9yIHRoZSBmaXJzdCB0aW1lLi4uXG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgYWxsb3dBdXRvSGVpZ2h0ICYmXG4gICAgICAgICAgICBSZWFjdC5pc1ZhbGlkRWxlbWVudChjaGlsZCkgJiZcbiAgICAgICAgICAgIGNoaWxkLnByb3BzLmhlaWdodCA9PT0gJ2F1dG8nICYmXG4gICAgICAgICAgICAvLyAuLi4gYW5kIG9ubHkgd2hlbiB0aGUgaGVpZ2h0IGlzIG5vdCBhbHJlYWR5IGJlZW4gY2FsY3VsYXRlZC5cbiAgICAgICAgICAgICFhdXRvSGVpZ2h0c1tpbmRleF1cbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIC4uLiByZW5kZXIgdGhlIGl0ZW0gaW4gYSBoZWxwZXIgZGl2LCB0aGUgcmVmIGlzIHVzZWQgdG8gY2FsY3VsYXRlXG4gICAgICAgICAgICAvLyB0aGUgaGVpZ2h0IG9mIGl0cyBjaGlsZHJlbi5cbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIDxkaXZcbiAgICAgICAgICAgICAgICByZWY9e3JlZiA9PiBvblZpcnR1YWxIZWxwZXJSZWYoaW5kZXgsIHJlZil9XG4gICAgICAgICAgICAgICAgZGF0YS12aXJ0dWFsLWluZGV4PXtpbmRleH1cbiAgICAgICAgICAgICAgICB7Li4ucHJvcHN9XG4gICAgICAgICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAuLi5wcm9wcy5zdHlsZVxuICAgICAgICAgICAgICAgIH19XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7Y2hpbGR9XG4gICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFdoZW4gYWxsb3dBdXRvSGVpZ2h0IGlzIGZhbHNlLCBvciB3aGVuIHRoZSBoZWlnaHQgaXMga25vd24uXG4gICAgICAgICAgLy8gU2ltcGx5IHJlbmRlciB0aGUgaXRlbS5cbiAgICAgICAgICByZXR1cm4gUmVhY3QuY2xvbmVFbGVtZW50KGNoaWxkLCBwcm9wcylcbiAgICAgICAgfX1cbiAgICAgIC8+XG4gICAgPC9QYW5lPlxuICApXG59KVxuXG5UYWJsZVZpcnR1YWxCb2R5LnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIENvbXBvc2VzIHRoZSBQYW5lIGNvbXBvbmVudCBhcyB0aGUgYmFzZS5cbiAgICovXG4gIC4uLlBhbmUucHJvcFR5cGVzLFxuXG4gIC8qKlxuICAgKiBDaGlsZHJlbiBuZWVkcyB0byBiZSBhbiBhcnJheSBvZiBhIHNpbmdsZSBub2RlLlxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5ub2RlKSwgUHJvcFR5cGVzLm5vZGVdKSxcblxuICAvKipcbiAgICogRGVmYXVsdCBoZWlnaHQgb2YgZWFjaCByb3cuXG4gICAqIDQ4IGlzIHRoZSBkZWZhdWx0IGhlaWdodCBvZiBhIFRhYmxlUm93LlxuICAgKi9cbiAgZGVmYXVsdEhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogV2hlbiB0cnVlLCBzdXBwb3J0IGBoZWlnaHQ9XCJhdXRvXCJgIG9uIGNoaWxkcmVuIGJlaW5nIHJlbmRlcmVkLlxuICAgKiBUaGlzIGlzIHNvbWV3aGF0IG9mIGFuIGV4cGlybWVudGFsIGZlYXR1cmUuXG4gICAqL1xuICBhbGxvd0F1dG9IZWlnaHQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgb3ZlcnNjYW5Db3VudCBwcm9wZXJ0eSBwYXNzZWQgdG8gcmVhY3QtdGlueS12aXJ0dWFsLWxpc3QuXG4gICAqL1xuICBvdmVyc2NhbkNvdW50OiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBXaGVuIHBhc3NlZCwgdGhpcyBpcyB1c2VkIGFzIHRoZSBgZXN0aW1hdGVkSXRlbVNpemVgIGluIHJlYWN0LXRpbnktdmlydHVhbC1saXN0LlxuICAgKiBPbmx5IHdoZW4gYGFsbG93QXV0b0hlaWdodGAgYW5kYHVzZUF2ZXJhZ2VBdXRvSGVpZ2h0RXN0aW1hdGlvbmAgYXJlIGZhbHNlLlxuICAgKi9cbiAgZXN0aW1hdGVkSXRlbVNpemU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIFdoZW4gYWxsb3dBdXRvSGVpZ2h0IGlzIHRydWUgYW5kIHRoaXMgcHJvcCBpcyB0cnVlLCB0aGUgZXN0aW1hdGVkIGhlaWdodFxuICAgKiB3aWxsIGJlIGNvbXB1dGVkIGJhc2VkIG9uIHRoZSBhdmVyYWdlIGhlaWdodCBvZiBhdXRvIGhlaWdodCByb3dzLlxuICAgKi9cbiAgdXNlQXZlcmFnZUF1dG9IZWlnaHRFc3RpbWF0aW9uOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIHNjcm9sbFRvSW5kZXggcHJvcGVydHkgcGFzc2VkIHRvIHJlYWN0LXRpbnktdmlydHVhbC1saXN0XG4gICAqL1xuICBzY3JvbGxUb0luZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogVGhlIHNjcm9sbE9mZnNldCBwcm9wZXJ0eSBwYXNzZWQgdG8gcmVhY3QtdGlueS12aXJ0dWFsLWxpc3RcbiAgICovXG4gIHNjcm9sbE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIFRoZSBzY3JvbGxUb0FsaWdubWVudCBwcm9wZXJ0eSBwYXNzZWQgdG8gcmVhY3QtdGlueS12aXJ0dWFsLWxpc3RcbiAgICovXG4gIHNjcm9sbFRvQWxpZ25tZW50OiBQcm9wVHlwZXMub25lT2YoWydzdGFydCcsICdjZW50ZXInLCAnZW5kJywgJ2F1dG8nXSksXG4gIC8qKlxuICAgKiBUaGUgb25TY3JvbGwgY2FsbGJhY2sgcGFzc2VkIHRvIHJlYWN0LXRpbnktdmlydHVhbC1saXN0XG4gICAqL1xuICBvblNjcm9sbDogUHJvcFR5cGVzLmZ1bmNcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGFibGVWaXJ0dWFsQm9keVxuIl19
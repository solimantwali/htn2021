import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["value", "children", "onChange", "autoFocus", "spellCheck", "placeholder", "icon"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { memo, forwardRef, useCallback } from 'react';
import { css } from 'glamor';
import PropTypes from 'prop-types';
import { SearchIcon } from '../../icons';
import { IconWrapper } from '../../icons/src/IconWrapper';
import { Text } from '../../typography';
import TableHeaderCell from './TableHeaderCell';
var invisibleInputClass = css({
  border: 'none',
  backgroundColor: 'transparent',
  WebkitAppearance: 'none',
  MozAppearance: 'none',
  WebkitFontSmoothing: 'antialiased',
  '&:focus': {
    outline: 'none'
  },
  '&::placeholder': {
    color: 'rgba(67, 90, 111, 0.7)'
  }
}).toString();

var noop = function noop() {};

var SearchTableHeaderCell = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function SearchTableHeaderCell(props, ref) {
  var value = props.value,
      children = props.children,
      _props$onChange = props.onChange,
      onChange = _props$onChange === void 0 ? noop : _props$onChange,
      autoFocus = props.autoFocus,
      _props$spellCheck = props.spellCheck,
      spellCheck = _props$spellCheck === void 0 ? true : _props$spellCheck,
      _props$placeholder = props.placeholder,
      placeholder = _props$placeholder === void 0 ? 'Filter...' : _props$placeholder,
      _props$icon = props.icon,
      icon = _props$icon === void 0 ? SearchIcon : _props$icon,
      rest = _objectWithoutProperties(props, _excluded);

  var handleChange = useCallback(function (e) {
    return onChange(e.target.value);
  }, [onChange]);
  return /*#__PURE__*/React.createElement(TableHeaderCell, rest, /*#__PURE__*/React.createElement(IconWrapper, {
    icon: icon,
    color: "muted",
    marginLeft: 2,
    marginRight: 10,
    size: 12
  }), /*#__PURE__*/React.createElement(Text, {
    is: "input",
    size: 300,
    flex: "1",
    className: invisibleInputClass,
    value: value,
    onChange: handleChange,
    autoFocus: autoFocus,
    spellCheck: spellCheck,
    fontWeight: 500,
    marginLeft: -2,
    paddingLeft: 0,
    placeholder: placeholder,
    ref: ref
  }));
}));
SearchTableHeaderCell.propTypes = _objectSpread(_objectSpread({}, TableHeaderCell.propTypes), {}, {
  /**
   * The value of the input.
   */
  value: PropTypes.string,

  /**
   * Handler to be called when the input changes.
   */
  onChange: PropTypes.func,

  /**
   * Sets whether the component should be automatically focused on component render.
   */
  autoFocus: PropTypes.bool,

  /**
   * Sets whether to apply spell checking to the content.
   */
  spellCheck: PropTypes.bool,

  /**
   * Text to display in the input if the input is empty.
   */
  placeholder: PropTypes.string,

  /**
   * The Evergreen or custom icon before the label.
   */
  icon: PropTypes.oneOfType([PropTypes.elementType, PropTypes.element])
});
export default SearchTableHeaderCell;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJsZS9zcmMvU2VhcmNoVGFibGVIZWFkZXJDZWxsLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwibWVtbyIsImZvcndhcmRSZWYiLCJ1c2VDYWxsYmFjayIsImNzcyIsIlByb3BUeXBlcyIsIlNlYXJjaEljb24iLCJJY29uV3JhcHBlciIsIlRleHQiLCJUYWJsZUhlYWRlckNlbGwiLCJpbnZpc2libGVJbnB1dENsYXNzIiwiYm9yZGVyIiwiYmFja2dyb3VuZENvbG9yIiwiV2Via2l0QXBwZWFyYW5jZSIsIk1vekFwcGVhcmFuY2UiLCJXZWJraXRGb250U21vb3RoaW5nIiwib3V0bGluZSIsImNvbG9yIiwidG9TdHJpbmciLCJub29wIiwiU2VhcmNoVGFibGVIZWFkZXJDZWxsIiwicHJvcHMiLCJyZWYiLCJ2YWx1ZSIsImNoaWxkcmVuIiwib25DaGFuZ2UiLCJhdXRvRm9jdXMiLCJzcGVsbENoZWNrIiwicGxhY2Vob2xkZXIiLCJpY29uIiwicmVzdCIsImhhbmRsZUNoYW5nZSIsImUiLCJ0YXJnZXQiLCJwcm9wVHlwZXMiLCJzdHJpbmciLCJmdW5jIiwiYm9vbCIsIm9uZU9mVHlwZSIsImVsZW1lbnRUeXBlIiwiZWxlbWVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxJQUFoQixFQUFzQkMsVUFBdEIsRUFBa0NDLFdBQWxDLFFBQXFELE9BQXJEO0FBQ0EsU0FBU0MsR0FBVCxRQUFvQixRQUFwQjtBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxTQUFTQyxVQUFULFFBQTJCLGFBQTNCO0FBQ0EsU0FBU0MsV0FBVCxRQUE0Qiw2QkFBNUI7QUFDQSxTQUFTQyxJQUFULFFBQXFCLGtCQUFyQjtBQUNBLE9BQU9DLGVBQVAsTUFBNEIsbUJBQTVCO0FBRUEsSUFBTUMsbUJBQW1CLEdBQUdOLEdBQUcsQ0FBQztBQUM5Qk8sRUFBQUEsTUFBTSxFQUFFLE1BRHNCO0FBRTlCQyxFQUFBQSxlQUFlLEVB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O0FBQ0Y7QUFDQTtBQUNFTixFQUFBQSxJQUFJLEVBQUV4QixTQUFTLENBQUNpQyxTQUFWLENBQW9CLENBQUNqQyxTQUFTLENBQUNrQyxXQUFYLEVBQXdCbEMsU0FBUyxDQUFDbUMsT0FBbEMsQ0FBcEI7QUFsQ1I7QUFxQ0EsZUFBZXBCLHFCQUFmIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IG1lbW8sIGZvcndhcmRSZWYsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBjc3MgfSBmcm9tICdnbGFtb3InXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgeyBTZWFyY2hJY29uIH0gZnJvbSAnLi4vLi4vaWNvbnMnXG5pbXBvcnQgeyBJY29uV3JhcHBlciB9IGZyb20gJy4uLy4uL2ljb25zL3NyYy9JY29uV3JhcHBlcidcbmltcG9ydCB7IFRleHQgfSBmcm9tICcuLi8uLi90eXBvZ3JhcGh5J1xuaW1wb3J0IFRhYmxlSGVhZGVyQ2VsbCBmcm9tICcuL1RhYmxlSGVhZGVyQ2VsbCdcblxuY29uc3QgaW52aXNpYmxlSW5wdXRDbGFzcyA9IGNzcyh7XG4gIGJvcmRlcjogJ25vbmUnLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gIFdlYmtpdEFwcGVhcmFuY2U6ICdub25lJyxcbiAgTW96QXBwZWFyYW5jZTogJ25vbmUnLFxuICBXZWJraXRGb250U21vb3RoaW5nOiAnYW50aWFsaWFzZWQnLFxuXG4gICcmOmZvY3VzJzoge1xuICAgIG91dGxpbmU6ICdub25lJ1xuICB9LFxuXG4gICcmOjpwbGFjZWhvbGRlcic6IHtcbiAgICBjb2xvcjogJ3JnYmEoNjcsIDkwLCAxMTEsIDAuNyknXG4gIH1cbn0pLnRvU3RyaW5nKClcblxuY29uc3Qgbm9vcCA9ICgpID0+IHt9XG5cbmNvbnN0IFNlYXJjaFRhYmxlSGVhZGVyQ2VsbCA9IG1lbW8oXG4gIGZvcndhcmRSZWYoZnVuY3Rpb24gU2VhcmNoVGFibGVIZWFkZXJDZWxsKHByb3BzLCByZWYpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGNoaWxkcmVuLFxuICAgICAgb25DaGFuZ2UgPSBub29wLFxuICAgICAgYXV0b0ZvY3VzLFxuICAgICAgc3BlbGxDaGVjayA9IHRydWUsXG4gICAgICBwbGFjZWhvbGRlciA9ICdGaWx0ZXIuLi4nLFxuICAgICAgaWNvbiA9IFNlYXJjaEljb24sXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IHByb3BzXG5cbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjayhlID0+IG9uQ2hhbmdlKGUudGFyZ2V0LnZhbHVlKSwgW29uQ2hhbmdlXSlcblxuICAgIHJldHVybiAoXG4gICAgICA8VGFibGVIZWFkZXJDZWxsIHsuLi5yZXN0fT5cbiAgICAgICAgPEljb25XcmFwcGVyIGljb249e2ljb259IGNvbG9yPVwibXV0ZWRcIiBtYXJnaW5MZWZ0PXsyfSBtYXJnaW5SaWdodD17MTB9IHNpemU9ezEyfSAvPlxuICAgICAgICA8VGV4dFxuICAgICAgICAgIGlzPVwiaW5wdXRcIlxuICAgICAgICAgIHNpemU9ezMwMH1cbiAgICAgICAgICBmbGV4PVwiMVwiXG4gICAgICAgICAgY2xhc3NOYW1lPXtpbnZpc2libGVJbnB1dENsYXNzfVxuICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICBvbkNoYW5nZT17aGFuZGxlQ2hhbmdlfVxuICAgICAgICAgIGF1dG9Gb2N1cz17YXV0b0ZvY3VzfVxuICAgICAgICAgIHNwZWxsQ2hlY2s9e3NwZWxsQ2hlY2t9XG4gICAgICAgICAgZm9udFdlaWdodD17NTAwfVxuICAgICAgICAgIG1hcmdpbkxlZnQ9ey0yfVxuICAgICAgICAgIHBhZGRpbmdMZWZ0PXswfVxuICAgICAgICAgIHBsYWNlaG9sZGVyPXtwbGFjZWhvbGRlcn1cbiAgICAgICAgICByZWY9e3JlZn1cbiAgICAgICAgLz5cbiAgICAgIDwvVGFibGVIZWFkZXJDZWxsPlxuICAgIClcbiAgfSlcbilcblxuU2VhcmNoVGFibGVIZWFkZXJDZWxsLnByb3BUeXBlcyA9IHtcbiAgLyoqXG4gICAqIENvbXBvc2VzIHRoZSBUYWJsZUhlYWRlckNlbGwgY29tcG9uZW50IGFzIHRoZSBiYXNlLlxuICAgKi9cbiAgLi4uVGFibGVIZWFkZXJDZWxsLnByb3BUeXBlcyxcblxuICAvKipcbiAgICogVGhlIHZhbHVlIG9mIHRoZSBpbnB1dC5cbiAgICovXG4gIHZhbHVlOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBIYW5kbGVyIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBpbnB1dCBjaGFuZ2VzLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgYXV0b21hdGljYWxseSBmb2N1c2VkIG9uIGNvbXBvbmVudCByZW5kZXIuXG4gICAqL1xuICBhdXRvRm9jdXM6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgdG8gYXBwbHkgc3BlbGwgY2hlY2tpbmcgdG8gdGhlIGNvbnRlbnQuXG4gICAqL1xuICBzcGVsbENoZWNrOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGV4dCB0byBkaXNwbGF5IGluIHRoZSBpbnB1dCBpZiB0aGUgaW5wdXQgaXMgZW1wdHkuXG4gICAqL1xuICBwbGFjZWhvbGRlcjogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIEV2ZXJncmVlbiBvciBjdXN0b20gaWNvbiBiZWZvcmUgdGhlIGxhYmVsLlxuICAgKi9cbiAgaWNvbjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmVsZW1lbnRUeXBlLCBQcm9wVHlwZXMuZWxlbWVudF0pXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlYXJjaFRhYmxlSGVhZGVyQ2VsbFxuIl19
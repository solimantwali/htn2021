import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _extends from "@babel/runtime/helpers/esm/extends";
import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["delay", "size"],
    _excluded2 = ["height", "width"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { useState, useEffect, forwardRef, memo } from 'react';
import { css } from 'glamor';
import PropTypes from 'prop-types';
import Box from 'ui-box';
import { useStyleConfig } from '../../hooks';
var loadingKeyframes = css.keyframes('loading', {
  '0%': {
    transform: 'rotate(0)'
  },
  '100%': {
    transform: 'rotate(360deg)'
  }
});
var loadingCircleKeyframes = css.keyframes('loading-circle', {
  '0%': {
    strokeDashoffset: 600
  },
  '100%': {
    strokeDashoffset: 0
  }
});
var outerClass = css({
  animation: "".concat(loadingKeyframes, " 2s linear infinite")
}).toString();

var innerClass = function innerClass(color) {
  return css({
    strokeDashoffset: 600,
    strokeDasharray: 300,
    strokeWidth: 12,
    strokeMiterlimit: 10,
    strokeLinecap: 'round',
    animation: "".concat(loadingCircleKeyframes, " 1.6s cubic-bezier(0.4, 0.15, 0.6, 0.85) infinite"),
    stroke: color,
    fill: 'transparent'
  }).toString();
};

var emptyObject = {};
var Spinner = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function Spinner(_ref, ref) {
  var _ref$delay = _ref.delay,
      delay = _ref$delay === void 0 ? 0 : _ref$delay,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 'medium' : _ref$size,
      props = _objectWithoutProperties(_ref, _excluded);

  var _useState = useState(delay === 0),
      _useState2 = _slicedToArray(_useState, 2),
      isVisible = _useState2[0],
      setIsVisible = _useState2[1];

  var boxProps = useStyleConfig('Spinner', {
    size: size
  }, emptyObject, emptyObject);

  var _ref2 = typeof size === 'string' ? boxProps : {
    width: size,
    height: size
  },
      height = _ref2.height,
      width = _ref2.width,
      rest = _objectWithoutProperties(_ref2, _excluded2);

  useEffect(function () {
    var delayTimer = null;

    if (delay > 0) {
      delayTimer = setTimeout(function () {
        setIsVisible(true);
      }, delay);
    }

    return function () {
      clearTimeout(delayTimer);
    };
  }, [delay]);

  if (!isVisible) {
    return null;
  }

  return /*#__PURE__*/React.createElement(Box, _extends({
    width: width,
    height: height,
    lineHeight: 0
  }, props, rest, {
    ref: ref
  }), /*#__PURE__*/React.createElement(Box, {
    is: "svg",
    className: outerClass,
    x: "0px",
    y: "0px",
    viewBox: "0 0 150 150"
  }, /*#__PURE__*/React.createElement(Box, {
    is: "circle",
    className: innerClass(boxProps.color),
    cx: "75",
    cy: "75",
    r: "60"
  })));
}));
Spinner.propTypes = _objectSpread(_objectSpread({}, Box.propTypes), {}, {
  /**
   * Delay after which spinner should be visible.
   */
  delay: PropTypes.number,

  /**
   * The size of the spinner.
   */
  size: PropTypes.number
});
export default Spinner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9zcGlubmVyL3NyYy9TcGlubmVyLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlU3RhdGUiLCJ1c2VFZmZlY3QiLCJmb3J3YXJkUmVmIiwibWVtbyIsImNzcyIsIlByb3BUeXBlcyIsIkJveCIsInVzZVN0eWxlQ29uZmlnIiwibG9hZGluZ0tleWZyYW1lcyIsImtleWZyYW1lcyIsInRyYW5zZm9ybSIsImxvYWRpbmdDaXJjbGVLZXlmcmFtZXMiLCJzdHJva2VEYXNob2Zmc2V0Iiwib3V0ZXJDbGFzcyIsImFuaW1hdGlvbiIsInRvU3RyaW5nIiwiaW5uZXJDbGFzcyIsImNvbG9yIiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlV2lkdGgiLCJzdHJva2VNaXRlcmxpbWl0Iiwic3Ryb2tlTGluZWNhcCIsInN0cm9rZSIsImZpbGwiLCJlbXB0eU9iamVjdCIsIlNwaW5uZXIiLCJyZWYiLCJkZWxheSIsInNpemUiLCJwcm9wcyIsImlzVmlzaWJsZSIsInNldElzVmlzaWJsZSIsImJveFByb3BzIiwid2lkdGgiLCJoZWlnaHQiLCJyZXN0IiwiZGVsYXlUaW1lciIsInNldFRpbWVvdXQiLCJjbGVhclRpbWVvdXQiLCJwcm9wVHlwZXMiLCJudW1iZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQUEsT0FBT0EsS0FBUCxJQUFnQkMsUUFBaEIsRUFBMEJDLFNBQTFCLEVBQXFDQyxVQUFyQyxFQUFpREMsSUFBakQsUUFBNkQsT0FBN0Q7QUFDQSxTQUFTQyxHQUFULFFBQW9CLFFBQXBCO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLE9BQU9DLEdBQVAsTUFBZ0IsUUFBaEI7QUFDQSxTQUFTQyxjQUFULFFBQStCLGFBQS9CO0FBRUEsSUFBTUMsZ0JBQWdCLEdBQUdKLEdBQUcsQ0FBQ0ssU0FBSixDQUFjLFNBQWQsRUFBeUI7QUFDaEQsUUFBTTtBQUNKQyxJQUFBQSxTQUFTLEVBQUU7QUFEUCxHQUQwQztBQUloRCxVQUFRO0FBQ05BLElBQUFBLFNBQVMsRUFBRTtBQURMO0FBSndDLENBQXpCLENBQXpCO0FBU0EsSUFBTUMsc0JBQXNCLEdBQUdQLEdBQUcsQ0FBQ0ssU0FBSixDQUFjLGdCQUFkLEVBQWdDO0FBQzdELFFBQU07QUFDSkcsSUFBQUEsZ0JBQWdCLEVBQUU7QUFEZCxHQUR1RDtBQUk3RCxVQUFRO0FBQ05BLElBQUFBLGdCQUFnQixFQUFFO0FBRFo7QUFKcUQsQ0FBaEMsQ0FBL0I7QUFTQSxJQUFNQyxVQUFVLEdBQUdULEdBQUcsQ0FBQztBQUNyQlUsRUFBQUEsU0FBUyxZQUFLTixnQkFBTDtBQURZLENBQUQsQ0FBSCxDQUVoQk8sUUFGZ0IsRUFBbkI7O0FBSUEsSUFBTUMsVUFBVSxHQUFHLFNBQWJBLFVBQWEsQ0FBQUMsS0FBSztBQUFBLFNBQ3RCYixHQUFHLENBQUM7QUFDRlEsSUFBQUEsZ0JBQWdCLEVBQUUsR0FEaEI7QUFFRk0sSUFBQUEsZUFBZSxFQUFFLEdBRmY7QUFHRkMsSUFBQUEsV0FBVyxFQUFFLEVBSFg7QUFJRkMsSUFBQUEsZ0JBQWdCLEVBQUUsRUFKaEI7QUFLRkMsSUFBQUEsYUFBYSxFQUFFLE9BTGI7QUFNRlAsSUFBQUEsU0FBUyxZQUFLSCxzQkFBTCxzREFOUDtBQU9GVyxJQUFBQSxNQUFNLEVBQUVMLEtBUE47QUFRRk0sSUFBQUEsSUFBSSxFQUFFO0FBUkosR0FBRCxDQUFILENBU0dSLFFBVEgsRUFEc0I7QUFBQSxDQUF4Qjs7QUFZQSxJQUFNUyxXQUFXLEdBQUcsRUFBcEI7QUFFQSxJQUFNQyxPQUFPLGdCQUFHdEIsSUFBSSxlQUNsQkQsVUFBVSxDQUFDLFNBQVN1QixPQUFULE9BQTJEQyxHQUEzRCxFQUFnRTtBQUFBLHdCQUE3Q0MsS0FBNkM7QUFBQSxNQUE3Q0EsS0FBNkMsMkJBQXJDLENBQXFDO0FBQUEsdUJBQWxDQyxJQUFrQztBQUFBLE1BQWxDQSxJQUFrQywwQkFBM0IsUUFBMkI7QUFBQSxNQUFkQyxLQUFjOztBQUN6RSxrQkFBa0M3QixRQUFRLENBQUMyQixLQUFLLEtBQUssQ0FBWCxDQUExQztBQUFBO0FBQUEsTUFBT0csU0FBUDtBQUFBLE1BQWtCQyxZQUFsQjs7QUFFQSxNQUFNQyxRQUFRLEdBQUd6QixjQUFjLENBQUMsU0FBRCxFQUFZO0FBQUVxQixJQUFBQSxJQUFJLEVBQUpBO0FBQUYsR0FBWixFQUFzQkosV0FBdEIsRUFBbUNBLFdBQW5DLENBQS9COztBQUVBLGNBQW1DLE9BQU9JLElBQVAsS0FBZ0IsUUFBaEIsR0FBMkJJLFFBQTNCLEdBQXNDO0FBQUVDLElBQUFBLEtBQUssRUFBRUwsSUFBVDtBQUFlTSxJQUFBQSxNQUFNLEVBQUVOO0FBQXZCLEdBQXpFO0FBQUEsTUFBUU0sTUFBUixTQUFRQSxNQUFSO0FBQUEsTUFBZ0JELEtBQWhCLFNBQWdCQSxLQUFoQjtBQUFBLE1BQTBCRSxJQUExQjs7QUFFQWxDLEVBQUFBLFNBQVMsQ0FBQyxZQUFNO0FBQ2QsUUFBSW1DLFVBQVUsR0FBRyxJQUFqQjs7QUFDQSxRQUFJVCxLQUFLLEdBQUcsQ0FBWixFQUFlO0FBQ2JTLE1BQUFBLFVBQVUsR0FBR0MsVUFBVSxDQUFDLFlBQU07QUFDNUJOLFFBQUFBLFlBQVksQ0FBQyxJQUFELENBQVo7QUFDRCxPQUZzQixFQUVwQkosS0FGb0IsQ0FBdkI7QUFHRDs7QUFFRCxXQUFPLFlBQVc7QUFDaEJXLE1BQUFBLFlBQVksQ0FBQ0YsVUFBRCxDQUFaO0FBQ0QsS0FGRDtBQUdELEdBWFEsRUFXTixDQUFDVCxLQUFELENBWE0sQ0FBVDs7QUFhQSxNQUFJLENBQUNHLFNBQUwsRUFBZ0I7QUFDZCxXQUFPLElBQVA7QUFDRDs7QUFFRCxzQkFDRSxvQkFBQyxHQUFEO0FBQUssSUFBQSxLQUFLLEVBQUVHLEtBQVo7QUFBbUIsSUFBQSxNQUFNLEVBQUVDLE1BQTNCO0FBQW1DLElBQUEsVUFBVSxFQUFFO0FBQS9DLEtBQXNETCxLQUF0RCxFQUFpRU0sSUFBakU7QUFBdUUsSUFBQSxHQUFHLEVBQUVUO0FBQTVFLG1CQUNFLG9CQUFDLEdBQUQ7QUFBSyxJQUFBLEVBQUUsRUFBQyxLQUFSO0FBQWMsSUFBQSxTQUFTLEVBQUViLFVBQXpCO0FBQXFDLElBQUEsQ0FBQyxFQUFDLEtBQXZDO0FBQTZDLElBQUEsQ0FBQyxFQUFDLEtBQS9DO0FBQXFELElBQUEsT0FBTyxFQUFDO0FBQTdELGtCQUNFLG9CQUFDLEdBQUQ7QUFBSyxJQUFBLEVBQUUsRUFBQyxRQUFSO0FBQWlCLElBQUEsU0FBUyxFQUFFRyxVQUFVLENBQUNnQixRQUFRLENBQUNmLEtBQVYsQ0FBdEM7QUFBd0QsSUFBQSxFQUFFLEVBQUMsSUFBM0Q7QUFBZ0UsSUFBQSxFQUFFLEVBQUMsSUFBbkU7QUFBd0UsSUFBQSxDQUFDLEVBQUM7QUFBMUUsSUFERixDQURGLENBREY7QUFPRCxDQS9CUyxDQURRLENBQXBCO0FBbUNBUSxPQUFPLENBQUNjLFNBQVIsbUNBSUtqQyxHQUFHLENBQUNpQyxTQUpUO0FBTUU7QUFDRjtBQUNBO0FBQ0VaLEVBQUFBLEtBQUssRUFBRXRCLFNBQVMsQ0FBQ21DLE1BVG5COztBQVdFO0FBQ0Y7QUFDQTtBQUNFWixFQUFBQSxJQUFJLEVBQUV2QixTQUFTLENBQUNtQztBQWRsQjtBQWlCQSxlQUFlZixPQUFmIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlLCB1c2VFZmZlY3QsIGZvcndhcmRSZWYsIG1lbW8gfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IGNzcyB9IGZyb20gJ2dsYW1vcidcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBCb3ggZnJvbSAndWktYm94J1xuaW1wb3J0IHsgdXNlU3R5bGVDb25maWcgfSBmcm9tICcuLi8uLi9ob29rcydcblxuY29uc3QgbG9hZGluZ0tleWZyYW1lcyA9IGNzcy5rZXlmcmFtZXMoJ2xvYWRpbmcnLCB7XG4gICcwJSc6IHtcbiAgICB0cmFuc2Zvcm06ICdyb3RhdGUoMCknXG4gIH0sXG4gICcxMDAlJzoge1xuICAgIHRyYW5zZm9ybTogJ3JvdGF0ZSgzNjBkZWcpJ1xuICB9XG59KVxuXG5jb25zdCBsb2FkaW5nQ2lyY2xlS2V5ZnJhbWVzID0gY3NzLmtleWZyYW1lcygnbG9hZGluZy1jaXJjbGUnLCB7XG4gICcwJSc6IHtcbiAgICBzdHJva2VEYXNob2Zmc2V0OiA2MDBcbiAgfSxcbiAgJzEwMCUnOiB7XG4gICAgc3Ryb2tlRGFzaG9mZnNldDogMFxuICB9XG59KVxuXG5jb25zdCBvdXRlckNsYXNzID0gY3NzKHtcbiAgYW5pbWF0aW9uOiBgJHtsb2FkaW5nS2V5ZnJhbWVzfSAycyBsaW5lYXIgaW5maW5pdGVgXG59KS50b1N0cmluZygpXG5cbmNvbnN0IGlubmVyQ2xhc3MgPSBjb2xvciA9PlxuICBjc3Moe1xuICAgIHN0cm9rZURhc2hvZmZzZXQ6IDYwMCxcbiAgICBzdHJva2VEYXNoYXJyYXk6IDMwMCxcbiAgICBzdHJva2VXaWR0aDogMTIsXG4gICAgc3Ryb2tlTWl0ZXJsaW1pdDogMTAsXG4gICAgc3Ryb2tlTGluZWNhcDogJ3JvdW5kJyxcbiAgICBhbmltYXRpb246IGAke2xvYWRpbmdDaXJjbGVLZXlmcmFtZXN9IDEuNnMgY3ViaWMtYmV6aWVyKDAuNCwgMC4xNSwgMC42LCAwLjg1KSBpbmZpbml0ZWAsXG4gICAgc3Ryb2tlOiBjb2xvcixcbiAgICBmaWxsOiAndHJhbnNwYXJlbnQnXG4gIH0pLnRvU3RyaW5nKClcblxuY29uc3QgZW1wdHlPYmplY3QgPSB7fVxuXG5jb25zdCBTcGlubmVyID0gbWVtbyhcbiAgZm9yd2FyZFJlZihmdW5jdGlvbiBTcGlubmVyKHsgZGVsYXkgPSAwLCBzaXplID0gJ21lZGl1bScsIC4uLnByb3BzIH0sIHJlZikge1xuICAgIGNvbnN0IFtpc1Zpc2libGUsIHNldElzVmlzaWJsZV0gPSB1c2VTdGF0ZShkZWxheSA9PT0gMClcblxuICAgIGNvbnN0IGJveFByb3BzID0gdXNlU3R5bGVDb25maWcoJ1NwaW5uZXInLCB7IHNpemUgfSwgZW1wdHlPYmplY3QsIGVtcHR5T2JqZWN0KVxuXG4gICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoLCAuLi5yZXN0IH0gPSB0eXBlb2Ygc2l6ZSA9PT0gJ3N0cmluZycgPyBib3hQcm9wcyA6IHsgd2lkdGg6IHNpemUsIGhlaWdodDogc2l6ZSB9XG5cbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgbGV0IGRlbGF5VGltZXIgPSBudWxsXG4gICAgICBpZiAoZGVsYXkgPiAwKSB7XG4gICAgICAgIGRlbGF5VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBzZXRJc1Zpc2libGUodHJ1ZSlcbiAgICAgICAgfSwgZGVsYXkpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGRlbGF5VGltZXIpXG4gICAgICB9XG4gICAgfSwgW2RlbGF5XSlcblxuICAgIGlmICghaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICA8Qm94IHdpZHRoPXt3aWR0aH0gaGVpZ2h0PXtoZWlnaHR9IGxpbmVIZWlnaHQ9ezB9IHsuLi5wcm9wc30gey4uLnJlc3R9IHJlZj17cmVmfT5cbiAgICAgICAgPEJveCBpcz1cInN2Z1wiIGNsYXNzTmFtZT17b3V0ZXJDbGFzc30geD1cIjBweFwiIHk9XCIwcHhcIiB2aWV3Qm94PVwiMCAwIDE1MCAxNTBcIj5cbiAgICAgICAgICA8Qm94IGlzPVwiY2lyY2xlXCIgY2xhc3NOYW1lPXtpbm5lckNsYXNzKGJveFByb3BzLmNvbG9yKX0gY3g9XCI3NVwiIGN5PVwiNzVcIiByPVwiNjBcIiAvPlxuICAgICAgICA8L0JveD5cbiAgICAgIDwvQm94PlxuICAgIClcbiAgfSlcbilcblxuU3Bpbm5lci5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBDb21wb3NlcyB0aGUgQm94IGNvbXBvbmVudCBhcyB0aGUgYmFzZS5cbiAgICovXG4gIC4uLkJveC5wcm9wVHlwZXMsXG5cbiAgLyoqXG4gICAqIERlbGF5IGFmdGVyIHdoaWNoIHNwaW5uZXIgc2hvdWxkIGJlIHZpc2libGUuXG4gICAqL1xuICBkZWxheTogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogVGhlIHNpemUgb2YgdGhlIHNwaW5uZXIuXG4gICAqL1xuICBzaXplOiBQcm9wVHlwZXMubnVtYmVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNwaW5uZXJcbiJdfQ==
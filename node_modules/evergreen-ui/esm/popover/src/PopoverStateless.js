import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _extends from "@babel/runtime/helpers/esm/extends";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["children"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { memo, forwardRef } from 'react';
import PropTypes from 'prop-types';
import { Card } from '../../layers';
var PopoverStateless = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function PopoverStateless(props, ref) {
  var children = props.children,
      rest = _objectWithoutProperties(props, _excluded);

  return /*#__PURE__*/React.createElement(Card, _extends({
    role: "dialog",
    elevation: 3,
    overflow: "hidden",
    minWidth: 200,
    backgroundColor: "white",
    ref: ref
  }, rest), children);
}));
PopoverStateless.propTypes = _objectSpread(_objectSpread({}, Card.propTypes), {}, {
  /**
   * The content of the Popover.
   */
  children: PropTypes.node
});
export default PopoverStateless;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3BvdmVyL3NyYy9Qb3BvdmVyU3RhdGVsZXNzLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwibWVtbyIsImZvcndhcmRSZWYiLCJQcm9wVHlwZXMiLCJDYXJkIiwiUG9wb3ZlclN0YXRlbGVzcyIsInByb3BzIiwicmVmIiwiY2hpbGRyZW4iLCJyZXN0IiwicHJvcFR5cGVzIiwibm9kZSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsT0FBT0EsS0FBUCxJQUFnQkMsSUFBaEIsRUFBc0JDLFVBQXRCLFFBQXdDLE9BQXhDO0FBQ0EsT0FBT0MsU0FBUCxNQUFzQixZQUF0QjtBQUNBLFNBQVNDLElBQVQsUUFBcUIsY0FBckI7QUFFQSxJQUFNQyxnQkFBZ0IsZ0JBQUdKLElBQUksZUFDM0JDLFVBQVUsQ0FBQyxTQUFTRyxnQkFBVCxDQUEwQkMsS0FBMUIsRUFBaUNDLEdBQWpDLEVBQXNDO0FBQy9DLE1BQVFDLFFBQVIsR0FBOEJGLEtBQTlCLENBQVFFLFFBQVI7QUFBQSxNQUFxQkMsSUFBckIsNEJBQThCSCxLQUE5Qjs7QUFFQSxzQkFDRSxvQkFBQyxJQUFEO0FBQU0sSUFBQSxJQUFJLEVBQUMsUUFBWDtBQUFvQixJQUFBLFNBQVMsRUFBRSxDQUEvQjtBQUFrQyxJQUFBLFFBQVEsRUFBQyxRQUEzQztBQUFvRCxJQUFBLFFBQVEsRUFBRSxHQUE5RDtBQUFtRSxJQUFBLGVBQWUsRUFBQyxPQUFuRjtBQUEyRixJQUFBLEdBQUcsRUFBRUM7QUFBaEcsS0FBeUdFLElBQXpHLEdBQ0dELFFBREgsQ0FERjtBQUtELENBUlMsQ0FEaUIsQ0FBN0I7QUFZQUgsZ0JBQWdCLENBQUNLLFNBQWpCLG1DQUlLTixJQUFJLENBQUNNLFNBSlY7QUFNRTtBQUNGO0FBQ0E7QUFDRUYsRUFBQUEsUUFBUSxFQUFFTCxTQUFTLENBQUNRO0FBVHRCO0FBWUEsZUFBZU4sZ0JBQWYiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgbWVtbywgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IHsgQ2FyZCB9IGZyb20gJy4uLy4uL2xheWVycydcblxuY29uc3QgUG9wb3ZlclN0YXRlbGVzcyA9IG1lbW8oXG4gIGZvcndhcmRSZWYoZnVuY3Rpb24gUG9wb3ZlclN0YXRlbGVzcyhwcm9wcywgcmVmKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4ucmVzdCB9ID0gcHJvcHNcblxuICAgIHJldHVybiAoXG4gICAgICA8Q2FyZCByb2xlPVwiZGlhbG9nXCIgZWxldmF0aW9uPXszfSBvdmVyZmxvdz1cImhpZGRlblwiIG1pbldpZHRoPXsyMDB9IGJhY2tncm91bmRDb2xvcj1cIndoaXRlXCIgcmVmPXtyZWZ9IHsuLi5yZXN0fT5cbiAgICAgICAge2NoaWxkcmVufVxuICAgICAgPC9DYXJkPlxuICAgIClcbiAgfSlcbilcblxuUG9wb3ZlclN0YXRlbGVzcy5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBDb21wb3NlcyB0aGUgQ2FyZCBhcyB0aGUgYmFzZS5cbiAgICovXG4gIC4uLkNhcmQucHJvcFR5cGVzLFxuXG4gIC8qKlxuICAgKiBUaGUgY29udGVudCBvZiB0aGUgUG9wb3Zlci5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufVxuXG5leHBvcnQgZGVmYXVsdCBQb3BvdmVyU3RhdGVsZXNzXG4iXX0=
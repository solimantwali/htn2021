import _extends from "@babel/runtime/helpers/esm/extends";
import _defineProperty from "@babel/runtime/helpers/esm/defineProperty";
import _objectWithoutProperties from "@babel/runtime/helpers/esm/objectWithoutProperties";
var _excluded = ["appearance", "direction", "disabled", "is", "isSelected", "onKeyDown", "onSelect", "height", "className", "tabIndex"],
    _excluded2 = ["className"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

import React, { forwardRef, memo, useCallback } from 'react';
import cx from 'classnames';
import PropTypes from 'prop-types';
import { useClickable, useLatest, useStyleConfig } from '../../hooks';
import safeInvoke from '../../lib/safe-invoke';
import warning from '../../lib/warning';
import { Text } from '../../typography';

var noop = function noop() {};

var getInternalStyles = function getInternalStyles(direction) {
  return {
    alignItems: 'center',
    justifyContent: direction === 'horizontal' ? 'center' : 'flex-start',
    textDecoration: 'none',
    cursor: 'pointer',
    outline: 'none',
    WebkitFontSmoothing: 'antialiased',
    WebkitAppearance: 'none',
    MozAppearance: 'none',
    '&::-moz-focus-inner ': {
      border: 0
    },
    display: direction === 'horizontal' ? 'inline-flex' : 'flex',
    width: direction === 'horizontal' ? 'auto' : '100%'
  };
};

var pseudoSelectors = {
  _active: '&:active',
  _after: '&:after',
  _before: '&:before',
  _current: '&[aria-current="page"], &[aria-selected="true"]',
  _disabled: '&[aria-disabled="true"]',
  _focus: '&:focus',
  _hover: '&:hover'
};
var Tab = /*#__PURE__*/memo( /*#__PURE__*/forwardRef(function Tab(props, ref) {
  var _props$appearance = props.appearance,
      appearance = _props$appearance === void 0 ? 'secondary' : _props$appearance,
      _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'horizontal' : _props$direction,
      _props$disabled = props.disabled,
      disabled = _props$disabled === void 0 ? false : _props$disabled,
      _props$is = props.is,
      is = _props$is === void 0 ? 'span' : _props$is,
      isSelected = props.isSelected,
      _props$onKeyDown = props.onKeyDown,
      onKeyDown = _props$onKeyDown === void 0 ? noop : _props$onKeyDown,
      _props$onSelect = props.onSelect,
      onSelect = _props$onSelect === void 0 ? noop : _props$onSelect,
      _props$height = props.height,
      height = _props$height === void 0 ? 28 : _props$height,
      className = props.className,
      tabIndex = props.tabIndex,
      rest = _objectWithoutProperties(props, _excluded);

  var _useStyleConfig = useStyleConfig('Tab', {
    appearance: appearance,
    direction: direction
  }, pseudoSelectors, getInternalStyles(direction)),
      themedClassName = _useStyleConfig.className,
      boxProps = _objectWithoutProperties(_useStyleConfig, _excluded2);

  var onClickRef = useLatest(props.onClick);
  var handleClick = useCallback(function (event) {
    safeInvoke(onClickRef.current, event);

    if (!disabled) {
      onSelect();
    }
  }, // onClickRef is a ref, but eslint can't figure that out
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [disabled, onSelect]);
  var clickableProps = useClickable({
    disabled: disabled,
    onKeyDown: onKeyDown,
    tabIndex: tabIndex
  });

  if (process.env.NODE_ENV !== 'production') {
    warning(typeof props.onClick === 'function', '<Tab> expects `onSelect` prop, but you passed `onClick`.');
  }

  var elementBasedProps;

  if (disabled) {
    elementBasedProps = {
      'aria-disabled': true
    };
  }

  if (is === 'a') {
    // Use aria-current when it's a link
    // https://tink.uk/using-the-aria-current-attribute/
    elementBasedProps = isSelected ? _objectSpread(_objectSpread({}, elementBasedProps), {}, {
      'aria-current': 'page'
    }) : {};
  } else {
    // Use a role="tablist" around the tabs
    // Also pass down a aria-controls="panelId"
    // https://www.stefanjudis.com/blog/aria-selected-and-when-to-use-it/
    elementBasedProps = _objectSpread(_objectSpread({}, elementBasedProps), {}, {
      'aria-selected': isSelected,
      role: 'tab'
    });
  }

  return /*#__PURE__*/React.createElement(Text, _extends({
    className: cx(className, themedClassName),
    is: is,
    size: 300,
    height: height,
    ref: ref,
    tabIndex: 0
  }, boxProps, rest, {
    onClick: handleClick
  }, clickableProps, elementBasedProps));
}));
Tab.propTypes = _objectSpread(_objectSpread({}, Text.propTypes), {}, {
  /**
   * Function triggered when tab is selected.
   */
  onSelect: PropTypes.func,

  /**
   * When true, the tab is selected.
   */
  isSelected: PropTypes.bool,

  /**
   * The appearance of the tab.
   * The default theme has primary, and secondary. The default is secondary
   */
  appearance: PropTypes.string,

  /**
   * The directionality of the tab.
   * If the tab is apart of a vertical or horizontal list
   */
  direction: PropTypes.oneOf(['horizontal', 'vertical']),

  /**
   * Class name passed to the Tab.
   * Only use this if you know what you are doing.
   */
  className: PropTypes.string
});
export default Tab;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy90YWJzL3NyYy9UYWIuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJmb3J3YXJkUmVmIiwibWVtbyIsInVzZUNhbGxiYWNrIiwiY3giLCJQcm9wVHlwZXMiLCJ1c2VDbGlja2FibGUiLCJ1c2VMYXRlc3QiLCJ1c2VTdHlsZUNvbmZpZyIsInNhZmVJbnZva2UiLCJ3YXJuaW5nIiwiVGV4dCIsIm5vb3AiLCJnZXRJbnRlcm5hbFN0eWxlcyIsImRpcmVjdGlvbiIsImFsaWduSXRlbXMiLCJqdXN0aWZ5Q29udGVudCIsInRleHREZWNvcmF0aW9uIiwiY3Vyc29yIiwib3V0bGluZSIsIldlYmtpdEZvbnRTbW9vdGhpbmciLCJXZWJraXRBcHBlYXJhbmNlIiwiTW96QXBwZWFyYW5jZSIsImJvcmRlciIsImRpc3BsYXkiLCJ3aWR0aCIsInBzZXVkb1NlbGVjdG9ycyIsIl9hY3RpdmUiLCJfYWZ0ZXIiLCJfYmVmb3JlIiwiX2N1cnJlbnQiLCJfZGlzYWJsZWQiLCJfZm9jdXMiLCJfaG92ZXIiLCJUYWIiLCJwcm9wcyIsInJlZiIsImFwcGVhcmFuY2UiLCJkaXNhYmxlZCIsImlzIiwiaXNTZWxlY3RlZCIsIm9uS2V5RG93biIsIm9uU2VsZWN0IiwiaGVpZ2h0IiwiY2xhc3NOYW1lIiwidGFiSW5kZXgiLCJyZXN0IiwidGhlbWVkQ2xhc3NOYW1lIiwiYm94UHJvcHMiLCJvbkNsaWNrUmVmIiwib25DbGljayIsImhhbmRsZUNsaWNrIiwiZXZlbnQiLCJjdXJyZW50IiwiY2xpY2thYmxlUHJvcHMiLCJwcm9jZXNzIiwiZW52IiwiTk9ERV9FTlYiLCJlbGVtZW50QmFzZWRQcm9wcyIsInJvbGUiLCJwcm9wVHlwZXMiLCJmdW5jIiwiYm9vbCIsInN0cmluZyIsIm9uZU9mIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsT0FBT0EsS0FBUCxJQUFnQkMsVUFBaEIsRUFBNEJDLElBQTVCLEVBQWtDQyxXQUFsQyxRQUFxRCxPQUFyRDtBQUNBLE9BQU9DLEVB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SUFBRDtBQUNFLElBQUEsU0FBUyxFQUFFdkQsRUFBRSxDQUFDd0MsU0FBRCxFQUFZRyxlQUFaLENBRGY7QUFFRSxJQUFBLEVBQUUsRUFBRVIsRUFGTjtBQUdFLElBQUEsSUFBSSxFQUFFLEdBSFI7QUFJRSxJQUFBLE1BQU0sRUFBRUksTUFKVjtBQUtFLElBQUEsR0FBRyxFQUFFUCxHQUxQO0FBTUUsSUFBQSxRQUFRLEVBQUU7QUFOWixLQU9NWSxRQVBOLEVBUU1GLElBUk47QUFTRSxJQUFBLE9BQU8sRUFBRUs7QUFUWCxLQVVNRyxjQVZOLEVBV01JLGlCQVhOLEVBREY7QUFlRCxDQW5GUyxDQURJLENBQWhCO0FBdUZBeEIsR0FBRyxDQUFDMEIsU0FBSixtQ0FJS2pELElBQUksQ0FBQ2lELFNBSlY7QUFNRTtBQUNGO0FBQ0E7QUFDRWxCLEVBQUFBLFFBQVEsRUFBRXJDLFNBQVMsQ0FBQ3dELElBVHRCOztBQVdFO0FBQ0Y7QUFDQTtBQUNFckIsRUFBQUEsVUFBVSxFQUFFbkMsU0FBUyxDQUFDeUQsSUFkeEI7O0FBZ0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0V6QixFQUFBQSxVQUFVLEVBQUVoQyxTQUFTLENBQUMwRCxNQXBCeEI7O0FBc0JFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0VqRCxFQUFBQSxTQUFTLEVBQUVULFNBQVMsQ0FBQzJELEtBQVYsQ0FBZ0IsQ0FBQyxZQUFELEVBQWUsVUFBZixDQUFoQixDQTFCYjs7QUE0QkU7QUFDRjtBQUNBO0FBQ0E7QUFDRXBCLEVBQUFBLFNBQVMsRUFBRXZDLFNBQVMsQ0FBQzBEO0FBaEN2QjtBQW1DQSxlQUFlN0IsR0FBZiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCBtZW1vLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IGN4IGZyb20gJ2NsYXNzbmFtZXMnXG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnXG5pbXBvcnQgeyB1c2VDbGlja2FibGUsIHVzZUxhdGVzdCwgdXNlU3R5bGVDb25maWcgfSBmcm9tICcuLi8uLi9ob29rcydcbmltcG9ydCBzYWZlSW52b2tlIGZyb20gJy4uLy4uL2xpYi9zYWZlLWludm9rZSdcbmltcG9ydCB3YXJuaW5nIGZyb20gJy4uLy4uL2xpYi93YXJuaW5nJ1xuaW1wb3J0IHsgVGV4dCB9IGZyb20gJy4uLy4uL3R5cG9ncmFwaHknXG5cbmNvbnN0IG5vb3AgPSAoKSA9PiB7fVxuXG5jb25zdCBnZXRJbnRlcm5hbFN0eWxlcyA9IGRpcmVjdGlvbiA9PiAoe1xuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAganVzdGlmeUNvbnRlbnQ6IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2NlbnRlcicgOiAnZmxleC1zdGFydCcsXG4gIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXG4gIGN1cnNvcjogJ3BvaW50ZXInLFxuICBvdXRsaW5lOiAnbm9uZScsXG4gIFdlYmtpdEZvbnRTbW9vdGhpbmc6ICdhbnRpYWxpYXNlZCcsXG4gIFdlYmtpdEFwcGVhcmFuY2U6ICdub25lJyxcbiAgTW96QXBwZWFyYW5jZTogJ25vbmUnLFxuICAnJjo6LW1vei1mb2N1cy1pbm5lciAnOiB7XG4gICAgYm9yZGVyOiAwXG4gIH0sXG4gIGRpc3BsYXk6IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2lubGluZS1mbGV4JyA6ICdmbGV4JyxcbiAgd2lkdGg6IGRpcmVjdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2F1dG8nIDogJzEwMCUnXG59KVxuXG5jb25zdCBwc2V1ZG9TZWxlY3RvcnMgPSB7XG4gIF9hY3RpdmU6ICcmOmFjdGl2ZScsXG4gIF9hZnRlcjogJyY6YWZ0ZXInLFxuICBfYmVmb3JlOiAnJjpiZWZvcmUnLFxuICBfY3VycmVudDogJyZbYXJpYS1jdXJyZW50PVwicGFnZVwiXSwgJlthcmlhLXNlbGVjdGVkPVwidHJ1ZVwiXScsXG4gIF9kaXNhYmxlZDogJyZbYXJpYS1kaXNhYmxlZD1cInRydWVcIl0nLFxuICBfZm9jdXM6ICcmOmZvY3VzJyxcbiAgX2hvdmVyOiAnJjpob3Zlcidcbn1cblxuY29uc3QgVGFiID0gbWVtbyhcbiAgZm9yd2FyZFJlZihmdW5jdGlvbiBUYWIocHJvcHMsIHJlZikge1xuICAgIGNvbnN0IHtcbiAgICAgIGFwcGVhcmFuY2UgPSAnc2Vjb25kYXJ5JyxcbiAgICAgIGRpcmVjdGlvbiA9ICdob3Jpem9udGFsJyxcbiAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICBpcyA9ICdzcGFuJyxcbiAgICAgIGlzU2VsZWN0ZWQsXG4gICAgICBvbktleURvd24gPSBub29wLFxuICAgICAgb25TZWxlY3QgPSBub29wLFxuICAgICAgaGVpZ2h0ID0gMjgsXG4gICAgICBjbGFzc05hbWUsXG4gICAgICB0YWJJbmRleCxcbiAgICAgIC4uLnJlc3RcbiAgICB9ID0gcHJvcHNcblxuICAgIGNvbnN0IHsgY2xhc3NOYW1lOiB0aGVtZWRDbGFzc05hbWUsIC4uLmJveFByb3BzIH0gPSB1c2VTdHlsZUNvbmZpZyhcbiAgICAgICdUYWInLFxuICAgICAgeyBhcHBlYXJhbmNlLCBkaXJlY3Rpb24gfSxcbiAgICAgIHBzZXVkb1NlbGVjdG9ycyxcbiAgICAgIGdldEludGVybmFsU3R5bGVzKGRpcmVjdGlvbilcbiAgICApXG5cbiAgICBjb25zdCBvbkNsaWNrUmVmID0gdXNlTGF0ZXN0KHByb3BzLm9uQ2xpY2spXG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSB1c2VDYWxsYmFjayhcbiAgICAgIGV2ZW50ID0+IHtcbiAgICAgICAgc2FmZUludm9rZShvbkNsaWNrUmVmLmN1cnJlbnQsIGV2ZW50KVxuICAgICAgICBpZiAoIWRpc2FibGVkKSB7XG4gICAgICAgICAgb25TZWxlY3QoKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gb25DbGlja1JlZiBpcyBhIHJlZiwgYnV0IGVzbGludCBjYW4ndCBmaWd1cmUgdGhhdCBvdXRcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgIFtkaXNhYmxlZCwgb25TZWxlY3RdXG4gICAgKVxuXG4gICAgY29uc3QgY2xpY2thYmxlUHJvcHMgPSB1c2VDbGlja2FibGUoeyBkaXNhYmxlZCwgb25LZXlEb3duLCB0YWJJbmRleCB9KVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm5pbmcodHlwZW9mIHByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicsICc8VGFiPiBleHBlY3RzIGBvblNlbGVjdGAgcHJvcCwgYnV0IHlvdSBwYXNzZWQgYG9uQ2xpY2tgLicpXG4gICAgfVxuXG4gICAgbGV0IGVsZW1lbnRCYXNlZFByb3BzXG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICBlbGVtZW50QmFzZWRQcm9wcyA9IHtcbiAgICAgICAgJ2FyaWEtZGlzYWJsZWQnOiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGlzID09PSAnYScpIHtcbiAgICAgIC8vIFVzZSBhcmlhLWN1cnJlbnQgd2hlbiBpdCdzIGEgbGlua1xuICAgICAgLy8gaHR0cHM6Ly90aW5rLnVrL3VzaW5nLXRoZS1hcmlhLWN1cnJlbnQtYXR0cmlidXRlL1xuICAgICAgZWxlbWVudEJhc2VkUHJvcHMgPSBpc1NlbGVjdGVkXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4uZWxlbWVudEJhc2VkUHJvcHMsXG4gICAgICAgICAgICAnYXJpYS1jdXJyZW50JzogJ3BhZ2UnXG4gICAgICAgICAgfVxuICAgICAgICA6IHt9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVzZSBhIHJvbGU9XCJ0YWJsaXN0XCIgYXJvdW5kIHRoZSB0YWJzXG4gICAgICAvLyBBbHNvIHBhc3MgZG93biBhIGFyaWEtY29udHJvbHM9XCJwYW5lbElkXCJcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnN0ZWZhbmp1ZGlzLmNvbS9ibG9nL2FyaWEtc2VsZWN0ZWQtYW5kLXdoZW4tdG8tdXNlLWl0L1xuICAgICAgZWxlbWVudEJhc2VkUHJvcHMgPSB7XG4gICAgICAgIC4uLmVsZW1lbnRCYXNlZFByb3BzLFxuICAgICAgICAnYXJpYS1zZWxlY3RlZCc6IGlzU2VsZWN0ZWQsXG4gICAgICAgIHJvbGU6ICd0YWInXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChcbiAgICAgIDxUZXh0XG4gICAgICAgIGNsYXNzTmFtZT17Y3goY2xhc3NOYW1lLCB0aGVtZWRDbGFzc05hbWUpfVxuICAgICAgICBpcz17aXN9XG4gICAgICAgIHNpemU9ezMwMH1cbiAgICAgICAgaGVpZ2h0PXtoZWlnaHR9XG4gICAgICAgIHJlZj17cmVmfVxuICAgICAgICB0YWJJbmRleD17MH1cbiAgICAgICAgey4uLmJveFByb3BzfVxuICAgICAgICB7Li4ucmVzdH1cbiAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgIHsuLi5jbGlja2FibGVQcm9wc31cbiAgICAgICAgey4uLmVsZW1lbnRCYXNlZFByb3BzfVxuICAgICAgLz5cbiAgICApXG4gIH0pXG4pXG5cblRhYi5wcm9wVHlwZXMgPSB7XG4gIC8qKlxuICAgKiBDb21wb3NlcyB0aGUgVGV4dCBjb21wb25lbnQgYXMgdGhlIGJhc2UuXG4gICAqL1xuICAuLi5UZXh0LnByb3BUeXBlcyxcblxuICAvKipcbiAgICogRnVuY3Rpb24gdHJpZ2dlcmVkIHdoZW4gdGFiIGlzIHNlbGVjdGVkLlxuICAgKi9cbiAgb25TZWxlY3Q6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRydWUsIHRoZSB0YWIgaXMgc2VsZWN0ZWQuXG4gICAqL1xuICBpc1NlbGVjdGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogVGhlIGFwcGVhcmFuY2Ugb2YgdGhlIHRhYi5cbiAgICogVGhlIGRlZmF1bHQgdGhlbWUgaGFzIHByaW1hcnksIGFuZCBzZWNvbmRhcnkuIFRoZSBkZWZhdWx0IGlzIHNlY29uZGFyeVxuICAgKi9cbiAgYXBwZWFyYW5jZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogVGhlIGRpcmVjdGlvbmFsaXR5IG9mIHRoZSB0YWIuXG4gICAqIElmIHRoZSB0YWIgaXMgYXBhcnQgb2YgYSB2ZXJ0aWNhbCBvciBob3Jpem9udGFsIGxpc3RcbiAgICovXG4gIGRpcmVjdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddKSxcblxuICAvKipcbiAgICogQ2xhc3MgbmFtZSBwYXNzZWQgdG8gdGhlIFRhYi5cbiAgICogT25seSB1c2UgdGhpcyBpZiB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmdcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGFiXG4iXX0=
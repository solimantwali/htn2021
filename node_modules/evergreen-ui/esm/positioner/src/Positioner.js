import _slicedToArray from "@babel/runtime/helpers/esm/slicedToArray";
import React, { memo, useState, useEffect, useRef } from 'react';
import PropTypes from 'prop-types';
import { Transition } from 'react-transition-group';
import { StackingOrder, Position } from '../../constants';
import { useMergedRef, usePrevious } from '../../hooks';
import { Portal } from '../../portal';
import { Stack } from '../../stack';
import getPosition from './getPosition';
var animationEasing = {
  spring: 'cubic-bezier(0.175, 0.885, 0.320, 1.175)'
};

var getCSS = function getCSS(_ref) {
  var animationDuration = _ref.animationDuration,
      initialScale = _ref.initialScale;
  return {
    position: 'fixed',
    opacity: 0,
    transitionTimingFunction: animationEasing.spring,
    transitionDuration: "".concat(animationDuration, "ms"),
    transitionProperty: 'opacity, transform',
    transform: "scale(".concat(initialScale, ") translateY(-1px)"),
    '&[data-state="entering"], &[data-state="entered"]': {
      opacity: 1,
      visibility: 'visible',
      transform: 'scale(1)'
    },
    '&[data-state="exiting"]': {
      opacity: 0,
      transform: 'scale(1)'
    }
  };
};

var noop = function noop() {};

var initialDimensions = {
  left: 0,
  top: 0,
  height: 0,
  width: 0,
  transformOrigin: null
};
var Positioner = /*#__PURE__*/memo(function Positioner(props) {
  var target = props.target,
      isShown = props.isShown,
      children = props.children,
      _props$initialScale = props.initialScale,
      initialScale = _props$initialScale === void 0 ? 0.9 : _props$initialScale,
      _props$animationDurat = props.animationDuration,
      animationDuration = _props$animationDurat === void 0 ? 300 : _props$animationDurat,
      _props$position = props.position,
      position = _props$position === void 0 ? Position.BOTTOM : _props$position,
      _props$bodyOffset = props.bodyOffset,
      bodyOffset = _props$bodyOffset === void 0 ? 6 : _props$bodyOffset,
      _props$targetOffset = props.targetOffset,
      targetOffset = _props$targetOffset === void 0 ? 6 : _props$targetOffset,
      _props$onOpenComplete = props.onOpenComplete,
      onOpenComplete = _props$onOpenComplete === void 0 ? noop : _props$onOpenComplete,
      _props$onCloseComplet = props.onCloseComplete,
      onCloseComplete = _props$onCloseComplet === void 0 ? noop : _props$onCloseComplet;

  var _useState = useState(initialDimensions),
      _useState2 = _slicedToArray(_useState, 2),
      dimensions = _useState2[0],
      setDimensions = _useState2[1];

  var previousDimensions = usePrevious(dimensions, initialDimensions);
  var latestAnimationFrame = useRef();
  var transitionState = useRef();
  var positionerRef = useRef();
  var targetRef = useRef();
  var setTargetRef = useMergedRef(targetRef);
  var getRef = useMergedRef(positionerRef); // Call `update` whenever the component has "entered" and dimensions change

  useEffect(function () {
    if (transitionState.current === 'entered') {
      latestAnimationFrame.current = requestAnimationFrame(function () {
        update(previousDimensions.height, previousDimensions.width);
      });
    }

    return function () {
      if (latestAnimationFrame.current) {
        cancelAnimationFrame(latestAnimationFrame.current);
      }
    };
  }, [dimensions]);

  var handleEnter = function handleEnter() {
    transitionState.current = 'entered';
    update();
  };

  var update = function update() {
    var prevHeight = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var prevWidth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    if (!isShown || !targetRef.current || !positionerRef.current) return;
    var targetRect = targetRef.current.getBoundingClientRect();
    var hasEntered = positionerRef.current.getAttribute('data-state') === 'entered';
    var viewportHeight = document.documentElement.clientHeight;
    var viewportWidth = document.documentElement.clientWidth;
    var height;
    var width;

    if (hasEntered) {
      // Only when the animation is done should we opt-in to `getBoundingClientRect`
      var positionerRect = positionerRef.current.getBoundingClientRect(); // https://github.com/segmentio/evergreen/issues/255
      // We need to ceil the width and height to prevent jitter when
      // the window is zoomed (when `window.devicePixelRatio` is not an integer)

      height = Math.round(positionerRect.height);
      width = Math.round(positionerRect.width);
    } else {
      // When the animation is in flight use `offsetWidth/Height` which
      // does not calculate the `transform` property as part of its result.
      // There is still change on jitter during the animation (although unoticable)
      // When the browser is zoomed in â€” we fix this with `Math.max`.
      height = Math.max(positionerRef.current.offsetHeight, prevHeight);
      width = Math.max(positionerRef.current.offsetWidth, prevWidth);
    }

    var _getPosition = getPosition({
      position: position,
      targetRect: targetRect,
      targetOffset: targetOffset,
      dimensions: {
        height: height,
        width: width
      },
      viewport: {
        width: viewportWidth,
        height: viewportHeight
      },
      viewportOffset: bodyOffset
    }),
        rect = _getPosition.rect,
        transformOrigin = _getPosition.transformOrigin;

    setDimensions({
      left: rect.left,
      top: rect.top,
      height: height,
      width: width,
      transformOrigin: transformOrigin
    });
  };

  var handleExited = function handleExited() {
    transitionState.current = 'exited';
    setDimensions(initialDimensions);
    onCloseComplete();
  };

  return /*#__PURE__*/React.createElement(Stack, {
    value: StackingOrder.POSITIONER
  }, function (zIndex) {
    return /*#__PURE__*/React.createElement(React.Fragment, null, target({
      getRef: setTargetRef,
      isShown: isShown
    }), /*#__PURE__*/React.createElement(Transition, {
      nodeRef: positionerRef,
      appear: true,
      "in": isShown,
      timeout: animationDuration,
      onEnter: handleEnter,
      onEntered: onOpenComplete,
      onExited: handleExited,
      unmountOnExit: true
    }, function (state) {
      return /*#__PURE__*/React.createElement(Portal, null, children({
        top: dimensions.top,
        left: dimensions.left,
        state: state,
        zIndex: zIndex,
        css: getCSS({
          initialScale: initialScale,
          animationDuration: animationDuration
        }),
        style: {
          transformOrigin: dimensions.transformOrigin,
          left: dimensions.left,
          top: dimensions.top,
          zIndex: zIndex
        },
        getRef: getRef,
        animationDuration: animationDuration
      }));
    }));
  });
});
Positioner.propTypes = {
  /**
   * The position the element that is being positioned is on.
   * Smart positioning might override this.
   */
  position: PropTypes.oneOf([Position.TOP, Position.TOP_LEFT, Position.TOP_RIGHT, Position.BOTTOM, Position.BOTTOM_LEFT, Position.BOTTOM_RIGHT, Position.LEFT, Position.RIGHT]),

  /**
   * When true, show the element being positioned.
   */
  isShown: PropTypes.bool,

  /**
   * Function that returns the element being positioned.
   */
  children: PropTypes.func.isRequired,

  /**
   * The minimum distance from the body to the element being positioned.
   */
  bodyOffset: PropTypes.number,

  /**
   * The minimum distance from the target to the element being positioned.
   */
  targetOffset: PropTypes.number,

  /**
   * Function that should return a node for the target.
   * ({ getRef: () -> Ref, isShown: Bool }) -> React Node
   */
  target: PropTypes.func.isRequired,

  /**
   * Initial scale of the element being positioned.
   */
  initialScale: PropTypes.number,

  /**
   * Duration of the animation.
   */
  animationDuration: PropTypes.number,

  /**
   * Function that will be called when the exit transition is complete.
   */
  onCloseComplete: PropTypes.func,

  /**
   * Function that will be called when the enter transition is complete.
   */
  onOpenComplete: PropTypes.func
};
export default Positioner;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9wb3NpdGlvbmVyL3NyYy9Qb3NpdGlvbmVyLmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwibWVtbyIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwidXNlUmVmIiwiUHJvcFR5cGVzIiwiVHJhbnNpdGlvbiIsIlN0YWNraW5nT3JkZXIiLCJQb3NpdGlvbiIsInVzZU1lcmdlZFJlZiIsInVzZVByZXZpb3VzIiwiUG9ydGFsIiwiU3RhY2siLCJnZXRQb3NpdGlvbiIsImFuaW1hdGlvbkVhc2luZyIsInNwcmluZyIsImdldENTUyIsImFuaW1hdGlvbkR1cmF0aW9uIiwiaW5pdGlhbFNjYWxlIiwicG9zaXRpb24iLCJvcGFjaXR5IiwidHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uIiwidHJhbnNpdGlvbkR1cmF0aW9uIiwidHJhbnNpdGlvblByb3BlcnR5IiwidHJhbnNmb3JtIiwidmlzaWJpbGl0eSIsIm5vb3AiLCJpbml0aWFsRGltZW5zaW9ucyIsImxlZnQiLCJ0b3AiLCJoZWlnaHQiLCJ3aWR0aCIsInRyYW5zZm9ybU9yaWdpbiIsIlBvc2l0aW9uZXIiLCJwcm9wcyIsInRhcmdldCIsImlzU2hvd24iLCJjaGlsZHJlbiIsIkJPVFRPTSIsImJvZHlPZmZzZXQiLCJ0YXJnZXRPZmZzZXQiLCJvbk9wZW5Db21wbGV0ZSIsIm9uQ2xvc2VDb21wbGV0ZSIsImRpbWVuc2lvbnMiLCJzZXREaW1lbnNpb25zIiwicHJldmlvdXNEaW1lbnNpb25zIiwibGF0ZXN0QW5pbWF0aW9uRnJhbWUiLCJ0cmFuc2l0aW9uU3RhdGUiLCJwb3NpdGlvbmVyUmVmIiwidGFyZ2V0UmVmIiwic2V0VGFyZ2V0UmVmIiwiZ2V0UmVmIiwiY3VycmVudCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInVwZGF0ZSIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlRW50ZXIiLCJwcmV2SGVpZ2h0IiwicHJldldpZHRoIiwidGFyZ2V0UmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImhhc0VudGVyZWQiLCJnZXRBdHRyaWJ1dGUiLCJ2aWV3cG9ydEhlaWdodCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50SGVpZ2h0Iiwidmlld3BvcnRXaWR0aCIsImNsaWVudFdpZHRoIiwicG9zaXRpb25lclJlY3QiLCJNYXRoIiwicm91bmQiLCJtYXgiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsInZpZXdwb3J0Iiwidmlld3BvcnRPZmZzZXQiLCJyZWN0IiwiaGFuZGxlRXhpdGVkIiwiUE9TSVRJT05FUiIsInpJbmRleCIsInN0YXRlIiwiY3NzIiwic3R5bGUiLCJwcm9wVHlwZXMiLCJvbmVPZiIsIlRPUCIsIlRPUF9MRUZUIiwiVE9QX1JJR0hUIiwiQk9UVE9NX0xFRlQiLCJCT1RUT01fUklHSFQiLCJMRUZUIiwiUklHSFQiLCJib29sIiwiZnVuYyIsImlzUmVxdWlyZWQiLCJudW1iZXIiXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPQSxLQUFQLElBQWdCQyxJQUFoQixFQUFzQkMsUUFBdEIsRUFBZ0NDLFNBQWhDLEVBQTJDQyxNQUEzQyxRQUF5RCxPQUF6RDtBQUNBLE9BQU9DLFNBQVAsTUFBc0IsWUFBdEI7QUFDQSxTQUFTQyxVQUFULFFBQTJCLHdCQUEzQjtBQUNBLFNBQVNDLGFBQVQsRUFBd0JDLFFBQXhCLFFBQXdDLGlCQUF4QztBQUNBLFNBQVNDLFlBQVQsRUFBdUJDLFdBQXZCLFFBQTBDLGFBQTFDO0FBQ0EsU0FBU0MsTUFBVCxRQUF1QixjQUF2QjtBQUNBLFNBQVNDLEtBQVQsUUFBc0IsYUFBdEI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLGVBQXhCO0FBRUEsSUFBTUMsZUFBZSxHQUFHO0FBQ3RCQyxFQUFBQSxNQUFNLEVBQUU7QUFEYyxDQUF4Qjs7QUFJQSxJQUFNQyxNQUFNLEdBQUcsU0FBVEEsTUFBUztBQUFBLE1BQUdDLGlCQUFILFFBQUdBLGlCQUFIO0FBQUEsTUFBc0JDLFlBQXRCLFFBQXNCQSxZQUF0QjtBQUFBLFNBQTBDO0FBQ3ZEQyxJ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QUU5QixTQUFTLENBQUN5RixJQUFWLENBQWVDLFVBeENGOztBQTBDckI7QUFDRjtBQUNBO0FBQ0U3RSxFQUFBQSxZQUFZLEVBQUViLFNBQVMsQ0FBQzJGLE1BN0NIOztBQStDckI7QUFDRjtBQUNBO0FBQ0UvRSxFQUFBQSxpQkFBaUIsRUFBRVosU0FBUyxDQUFDMkYsTUFsRFI7O0FBb0RyQjtBQUNGO0FBQ0E7QUFDRXRELEVBQUFBLGVBQWUsRUFBRXJDLFNBQVMsQ0FBQ3lGLElBdkROOztBQXlEckI7QUFDRjtBQUNBO0FBQ0VyRCxFQUFBQSxjQUFjLEVBQUVwQyxTQUFTLENBQUN5RjtBQTVETCxDQUF2QjtBQStEQSxlQUFlN0QsVUFBZiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBtZW1vLCB1c2VTdGF0ZSwgdXNlRWZmZWN0LCB1c2VSZWYgfSBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCB7IFRyYW5zaXRpb24gfSBmcm9tICdyZWFjdC10cmFuc2l0aW9uLWdyb3VwJ1xuaW1wb3J0IHsgU3RhY2tpbmdPcmRlciwgUG9zaXRpb24gfSBmcm9tICcuLi8uLi9jb25zdGFudHMnXG5pbXBvcnQgeyB1c2VNZXJnZWRSZWYsIHVzZVByZXZpb3VzIH0gZnJvbSAnLi4vLi4vaG9va3MnXG5pbXBvcnQgeyBQb3J0YWwgfSBmcm9tICcuLi8uLi9wb3J0YWwnXG5pbXBvcnQgeyBTdGFjayB9IGZyb20gJy4uLy4uL3N0YWNrJ1xuaW1wb3J0IGdldFBvc2l0aW9uIGZyb20gJy4vZ2V0UG9zaXRpb24nXG5cbmNvbnN0IGFuaW1hdGlvbkVhc2luZyA9IHtcbiAgc3ByaW5nOiAnY3ViaWMtYmV6aWVyKDAuMTc1LCAwLjg4NSwgMC4zMjAsIDEuMTc1KSdcbn1cblxuY29uc3QgZ2V0Q1NTID0gKHsgYW5pbWF0aW9uRHVyYXRpb24sIGluaXRpYWxTY2FsZSB9KSA9PiAoe1xuICBwb3NpdGlvbjogJ2ZpeGVkJyxcbiAgb3BhY2l0eTogMCxcbiAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBhbmltYXRpb25FYXNpbmcuc3ByaW5nLFxuICB0cmFuc2l0aW9uRHVyYXRpb246IGAke2FuaW1hdGlvbkR1cmF0aW9ufW1zYCxcbiAgdHJhbnNpdGlvblByb3BlcnR5OiAnb3BhY2l0eSwgdHJhbnNmb3JtJyxcbiAgdHJhbnNmb3JtOiBgc2NhbGUoJHtpbml0aWFsU2NhbGV9KSB0cmFuc2xhdGVZKC0xcHgpYCxcbiAgJyZbZGF0YS1zdGF0ZT1cImVudGVyaW5nXCJdLCAmW2RhdGEtc3RhdGU9XCJlbnRlcmVkXCJdJzoge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgdmlzaWJpbGl0eTogJ3Zpc2libGUnLFxuICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJ1xuICB9LFxuICAnJltkYXRhLXN0YXRlPVwiZXhpdGluZ1wiXSc6IHtcbiAgICBvcGFjaXR5OiAwLFxuICAgIHRyYW5zZm9ybTogJ3NjYWxlKDEpJ1xuICB9XG59KVxuXG5jb25zdCBub29wID0gKCkgPT4ge31cbmNvbnN0IGluaXRpYWxEaW1lbnNpb25zID0ge1xuICBsZWZ0OiAwLFxuICB0b3A6IDAsXG4gIGhlaWdodDogMCxcbiAgd2lkdGg6IDAsXG4gIHRyYW5zZm9ybU9yaWdpbjogbnVsbFxufVxuXG5jb25zdCBQb3NpdGlvbmVyID0gbWVtbyhmdW5jdGlvbiBQb3NpdGlvbmVyKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICB0YXJnZXQsXG4gICAgaXNTaG93bixcbiAgICBjaGlsZHJlbixcbiAgICBpbml0aWFsU2NhbGUgPSAwLjksXG4gICAgYW5pbWF0aW9uRHVyYXRpb24gPSAzMDAsXG4gICAgcG9zaXRpb24gPSBQb3NpdGlvbi5CT1RUT00sXG4gICAgYm9keU9mZnNldCA9IDYsXG4gICAgdGFyZ2V0T2Zmc2V0ID0gNixcbiAgICBvbk9wZW5Db21wbGV0ZSA9IG5vb3AsXG4gICAgb25DbG9zZUNvbXBsZXRlID0gbm9vcFxuICB9ID0gcHJvcHNcblxuICBjb25zdCBbZGltZW5zaW9ucywgc2V0RGltZW5zaW9uc10gPSB1c2VTdGF0ZShpbml0aWFsRGltZW5zaW9ucylcbiAgY29uc3QgcHJldmlvdXNEaW1lbnNpb25zID0gdXNlUHJldmlvdXMoZGltZW5zaW9ucywgaW5pdGlhbERpbWVuc2lvbnMpXG4gIGNvbnN0IGxhdGVzdEFuaW1hdGlvbkZyYW1lID0gdXNlUmVmKClcbiAgY29uc3QgdHJhbnNpdGlvblN0YXRlID0gdXNlUmVmKClcbiAgY29uc3QgcG9zaXRpb25lclJlZiA9IHVzZVJlZigpXG4gIGNvbnN0IHRhcmdldFJlZiA9IHVzZVJlZigpXG4gIGNvbnN0IHNldFRhcmdldFJlZiA9IHVzZU1lcmdlZFJlZih0YXJnZXRSZWYpXG4gIGNvbnN0IGdldFJlZiA9IHVzZU1lcmdlZFJlZihwb3NpdGlvbmVyUmVmKVxuXG4gIC8vIENhbGwgYHVwZGF0ZWAgd2hlbmV2ZXIgdGhlIGNvbXBvbmVudCBoYXMgXCJlbnRlcmVkXCIgYW5kIGRpbWVuc2lvbnMgY2hhbmdlXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRyYW5zaXRpb25TdGF0ZS5jdXJyZW50ID09PSAnZW50ZXJlZCcpIHtcbiAgICAgIGxhdGVzdEFuaW1hdGlvbkZyYW1lLmN1cnJlbnQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICB1cGRhdGUocHJldmlvdXNEaW1lbnNpb25zLmhlaWdodCwgcHJldmlvdXNEaW1lbnNpb25zLndpZHRoKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgaWYgKGxhdGVzdEFuaW1hdGlvbkZyYW1lLmN1cnJlbnQpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUobGF0ZXN0QW5pbWF0aW9uRnJhbWUuY3VycmVudClcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtkaW1lbnNpb25zXSlcblxuICBjb25zdCBoYW5kbGVFbnRlciA9ICgpID0+IHtcbiAgICB0cmFuc2l0aW9uU3RhdGUuY3VycmVudCA9ICdlbnRlcmVkJ1xuICAgIHVwZGF0ZSgpXG4gIH1cblxuICBjb25zdCB1cGRhdGUgPSAocHJldkhlaWdodCA9IDAsIHByZXZXaWR0aCA9IDApID0+IHtcbiAgICBpZiAoIWlzU2hvd24gfHwgIXRhcmdldFJlZi5jdXJyZW50IHx8ICFwb3NpdGlvbmVyUmVmLmN1cnJlbnQpIHJldHVyblxuXG4gICAgY29uc3QgdGFyZ2V0UmVjdCA9IHRhcmdldFJlZi5jdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG5cbiAgICBjb25zdCBoYXNFbnRlcmVkID0gcG9zaXRpb25lclJlZi5jdXJyZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1zdGF0ZScpID09PSAnZW50ZXJlZCdcblxuICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuICAgIGNvbnN0IHZpZXdwb3J0V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGhcblxuICAgIGxldCBoZWlnaHRcbiAgICBsZXQgd2lkdGhcbiAgICBpZiAoaGFzRW50ZXJlZCkge1xuICAgICAgLy8gT25seSB3aGVuIHRoZSBhbmltYXRpb24gaXMgZG9uZSBzaG91bGQgd2Ugb3B0LWluIHRvIGBnZXRCb3VuZGluZ0NsaWVudFJlY3RgXG4gICAgICBjb25zdCBwb3NpdGlvbmVyUmVjdCA9IHBvc2l0aW9uZXJSZWYuY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc2VnbWVudGlvL2V2ZXJncmVlbi9pc3N1ZXMvMjU1XG4gICAgICAvLyBXZSBuZWVkIHRvIGNlaWwgdGhlIHdpZHRoIGFuZCBoZWlnaHQgdG8gcHJldmVudCBqaXR0ZXIgd2hlblxuICAgICAgLy8gdGhlIHdpbmRvdyBpcyB6b29tZWQgKHdoZW4gYHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvYCBpcyBub3QgYW4gaW50ZWdlcilcbiAgICAgIGhlaWdodCA9IE1hdGgucm91bmQocG9zaXRpb25lclJlY3QuaGVpZ2h0KVxuICAgICAgd2lkdGggPSBNYXRoLnJvdW5kKHBvc2l0aW9uZXJSZWN0LndpZHRoKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXaGVuIHRoZSBhbmltYXRpb24gaXMgaW4gZmxpZ2h0IHVzZSBgb2Zmc2V0V2lkdGgvSGVpZ2h0YCB3aGljaFxuICAgICAgLy8gZG9lcyBub3QgY2FsY3VsYXRlIHRoZSBgdHJhbnNmb3JtYCBwcm9wZXJ0eSBhcyBwYXJ0IG9mIGl0cyByZXN1bHQuXG4gICAgICAvLyBUaGVyZSBpcyBzdGlsbCBjaGFuZ2Ugb24gaml0dGVyIGR1cmluZyB0aGUgYW5pbWF0aW9uIChhbHRob3VnaCB1bm90aWNhYmxlKVxuICAgICAgLy8gV2hlbiB0aGUgYnJvd3NlciBpcyB6b29tZWQgaW4g4oCUIHdlIGZpeCB0aGlzIHdpdGggYE1hdGgubWF4YC5cbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KHBvc2l0aW9uZXJSZWYuY3VycmVudC5vZmZzZXRIZWlnaHQsIHByZXZIZWlnaHQpXG4gICAgICB3aWR0aCA9IE1hdGgubWF4KHBvc2l0aW9uZXJSZWYuY3VycmVudC5vZmZzZXRXaWR0aCwgcHJldldpZHRoKVxuICAgIH1cblxuICAgIGNvbnN0IHsgcmVjdCwgdHJhbnNmb3JtT3JpZ2luIH0gPSBnZXRQb3NpdGlvbih7XG4gICAgICBwb3NpdGlvbixcbiAgICAgIHRhcmdldFJlY3QsXG4gICAgICB0YXJnZXRPZmZzZXQsXG4gICAgICBkaW1lbnNpb25zOiB7XG4gICAgICAgIGhlaWdodCxcbiAgICAgICAgd2lkdGhcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICB3aWR0aDogdmlld3BvcnRXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB2aWV3cG9ydEhlaWdodFxuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0T2Zmc2V0OiBib2R5T2Zmc2V0XG4gICAgfSlcblxuICAgIHNldERpbWVuc2lvbnMoe1xuICAgICAgbGVmdDogcmVjdC5sZWZ0LFxuICAgICAgdG9wOiByZWN0LnRvcCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHdpZHRoLFxuICAgICAgdHJhbnNmb3JtT3JpZ2luXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IGhhbmRsZUV4aXRlZCA9ICgpID0+IHtcbiAgICB0cmFuc2l0aW9uU3RhdGUuY3VycmVudCA9ICdleGl0ZWQnXG4gICAgc2V0RGltZW5zaW9ucyhpbml0aWFsRGltZW5zaW9ucylcbiAgICBvbkNsb3NlQ29tcGxldGUoKVxuICB9XG5cbiAgcmV0dXJuIChcbiAgICA8U3RhY2sgdmFsdWU9e1N0YWNraW5nT3JkZXIuUE9TSVRJT05FUn0+XG4gICAgICB7ekluZGV4ID0+IHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICA8UmVhY3QuRnJhZ21lbnQ+XG4gICAgICAgICAgICB7dGFyZ2V0KHsgZ2V0UmVmOiBzZXRUYXJnZXRSZWYsIGlzU2hvd24gfSl9XG5cbiAgICAgICAgICAgIDxUcmFuc2l0aW9uXG4gICAgICAgICAgICAgIG5vZGVSZWY9e3Bvc2l0aW9uZXJSZWZ9XG4gICAgICAgICAgICAgIGFwcGVhclxuICAgICAgICAgICAgICBpbj17aXNTaG93bn1cbiAgICAgICAgICAgICAgdGltZW91dD17YW5pbWF0aW9uRHVyYXRpb259XG4gICAgICAgICAgICAgIG9uRW50ZXI9e2hhbmRsZUVudGVyfVxuICAgICAgICAgICAgICBvbkVudGVyZWQ9e29uT3BlbkNvbXBsZXRlfVxuICAgICAgICAgICAgICBvbkV4aXRlZD17aGFuZGxlRXhpdGVkfVxuICAgICAgICAgICAgICB1bm1vdW50T25FeGl0XG4gICAgICAgICAgICA+XG4gICAgICAgICAgICAgIHtzdGF0ZSA9PiAoXG4gICAgICAgICAgICAgICAgPFBvcnRhbD5cbiAgICAgICAgICAgICAgICAgIHtjaGlsZHJlbih7XG4gICAgICAgICAgICAgICAgICAgIHRvcDogZGltZW5zaW9ucy50b3AsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IGRpbWVuc2lvbnMubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgICAgICAgICAgY3NzOiBnZXRDU1Moe1xuICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxTY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25EdXJhdGlvblxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW46IGRpbWVuc2lvbnMudHJhbnNmb3JtT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGRpbWVuc2lvbnMubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICB0b3A6IGRpbWVuc2lvbnMudG9wLFxuICAgICAgICAgICAgICAgICAgICAgIHpJbmRleFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXRSZWYsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbkR1cmF0aW9uXG4gICAgICAgICAgICAgICAgICB9KX1cbiAgICAgICAgICAgICAgICA8L1BvcnRhbD5cbiAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgIDwvVHJhbnNpdGlvbj5cbiAgICAgICAgICA8L1JlYWN0LkZyYWdtZW50PlxuICAgICAgICApXG4gICAgICB9fVxuICAgIDwvU3RhY2s+XG4gIClcbn0pXG5cblBvc2l0aW9uZXIucHJvcFR5cGVzID0ge1xuICAvKipcbiAgICogVGhlIHBvc2l0aW9uIHRoZSBlbGVtZW50IHRoYXQgaXMgYmVpbmcgcG9zaXRpb25lZCBpcyBvbi5cbiAgICogU21hcnQgcG9zaXRpb25pbmcgbWlnaHQgb3ZlcnJpZGUgdGhpcy5cbiAgICovXG4gIHBvc2l0aW9uOiBQcm9wVHlwZXMub25lT2YoW1xuICAgIFBvc2l0aW9uLlRPUCxcbiAgICBQb3NpdGlvbi5UT1BfTEVGVCxcbiAgICBQb3NpdGlvbi5UT1BfUklHSFQsXG4gICAgUG9zaXRpb24uQk9UVE9NLFxuICAgIFBvc2l0aW9uLkJPVFRPTV9MRUZULFxuICAgIFBvc2l0aW9uLkJPVFRPTV9SSUdIVCxcbiAgICBQb3NpdGlvbi5MRUZULFxuICAgIFBvc2l0aW9uLlJJR0hUXG4gIF0pLFxuXG4gIC8qKlxuICAgKiBXaGVuIHRydWUsIHNob3cgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICovXG4gIGlzU2hvd246IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBkaXN0YW5jZSBmcm9tIHRoZSBib2R5IHRvIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gICAqL1xuICBib2R5T2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBUaGUgbWluaW11bSBkaXN0YW5jZSBmcm9tIHRoZSB0YXJnZXQgdG8gdGhlIGVsZW1lbnQgYmVpbmcgcG9zaXRpb25lZC5cbiAgICovXG4gIHRhcmdldE9mZnNldDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCBzaG91bGQgcmV0dXJuIGEgbm9kZSBmb3IgdGhlIHRhcmdldC5cbiAgICogKHsgZ2V0UmVmOiAoKSAtPiBSZWYsIGlzU2hvd246IEJvb2wgfSkgLT4gUmVhY3QgTm9kZVxuICAgKi9cbiAgdGFyZ2V0OiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuXG4gIC8qKlxuICAgKiBJbml0aWFsIHNjYWxlIG9mIHRoZSBlbGVtZW50IGJlaW5nIHBvc2l0aW9uZWQuXG4gICAqL1xuICBpbml0aWFsU2NhbGU6IFByb3BUeXBlcy5udW1iZXIsXG5cbiAgLyoqXG4gICAqIER1cmF0aW9uIG9mIHRoZSBhbmltYXRpb24uXG4gICAqL1xuICBhbmltYXRpb25EdXJhdGlvbjogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogRnVuY3Rpb24gdGhhdCB3aWxsIGJlIGNhbGxlZCB3aGVuIHRoZSBleGl0IHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAqL1xuICBvbkNsb3NlQ29tcGxldGU6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIHdoZW4gdGhlIGVudGVyIHRyYW5zaXRpb24gaXMgY29tcGxldGUuXG4gICAqL1xuICBvbk9wZW5Db21wbGV0ZTogUHJvcFR5cGVzLmZ1bmNcbn1cblxuZXhwb3J0IGRlZmF1bHQgUG9zaXRpb25lclxuIl19